<?php

/**
 * @file
 * Provides a generic CRM party entity.
 */

// @todo: If these contain only classes they will be autoloaded and these include statements can be dropped.
include_once("includes/crm_party_type.entity.inc");

/**
 * Implements hook_help().
 */
function crm_party_help($path, $arg) {
  switch ($path) {
    case 'admin/help#crm_party':
      return t("TODO: Create admin help text.");
    case 'admin/config/crm/labels':
      return t("Party name label generators save a label whenever a party is created or updated. This lets you form the party's label or name in a variety of methods.");
  }
}

/**
 * Implements hook_entity_info().
 *
 * Define 2 entities: 
 *  - The base Party Entity
 *  - The Hat entity
 *
 * @todo: Improve documentation
 * @todo: Party types?!
 */
function crm_party_entity_info() {
  $party_info['crm_party'] = array(
    'label' => t('Party'),
    'entity class' => 'CRMParty',
    'controller class' => 'CRMPartyController',
    // We define this so entity module provides us with basic Views data, while
    // allowing us to define more of our own.
    // See http://drupal.org/node/1307760.
    'views controller class' => 'EntityDefaultViewsController',
    'base table' => 'crm_party',
    //'uri callback' => 'crm_party_uri',
    'fieldable' => TRUE,
    'module' => 'crm_party',
    'entity keys' => array(
      'id' => 'pid',
      'bundle' => 'type',
    ),
    'exportable' => TRUE,
    //'static cache' => TRUE,
    'bundles' => array(
      'individual' => array(
        'label' => t('Individual Party'),
        'admin' => array(
          'path' => 'admin/community/party/manage/individual',
          'access arguments' => array('administer parties'),
        ),
      ),
      'organisation' => array(
        'label' => t('Organisation Party'),
        'admin' => array(
          'path' => 'admin/community/party/manage/organisation',
          'access arguments' => array('administer parties'),
        ),
      ),
    ),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full Contact'),
        'custom settings' =>  FALSE,
      ),
    )
  );
    
  return $party_info;
}

/**
 * Implements hook_entity_info_alter().
 *
 * We are adding the info about the model types via a hook to avoid a recursion
 * issue as loading the model types requires the entity info as well.
 *
 * @todo This needs to be improved
 *
function crm_party_entity_info_alter(&$entity_info) {
  foreach (crm_party_get_types() as $type => $info) {
    $entity_info['crm_party']['bundles'][$type] = array(
      'label' => $info->label,
      'admin' => array(
        'path' => 'admin/community/structure/party_types/manage/%crm_party_type',
        'real path' => 'admin/community/structure/party_types/manage/' . $type,
        'bundle argument' => 4,
        'access arguments' => array('administer party types'),
      ),
    );
  }
}
*/

/**
 * Implements hook_menu().
 */
function crm_party_menu() {
  // CRM settings.
  // Making up a new config category.
  // Alternative is to put this all under top-level admin.
  // But all this structure is rough anyway.
  $items['admin/config/crm'] = array(
    'title' => 'CRM',
    'description' => 'CRM settings.',
    'position' => 'left',
    'weight' => -10,
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('access administration pages'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );
  $items['admin/config/crm/labels'] = array(
    'title' => 'Labels',
    'description' => 'Determine how labels for parties are generated.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('crm_party_settings_label_plugin_form'),
    'access arguments' => array('administer crm settings'),
    'file' => 'crm_party.admin.inc',
  );
  $items['admin/config/crm/piece-order'] = array(
    'title' => 'Piece order',
    'description' => 'Rearrange the order of pieces within a party.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('crm_party_settings_pieces_order_form'),
    'access arguments' => array('administer crm settings'),
    'file' => 'crm_party.admin.inc',
  );

  $items['admin/community'] = array(
    'title' => 'Community',
    'description' => 'Manage the community',
    'page callback' => 'crm_party_admin',
    'page arguments' => array('list'),
    'access arguments' => array('administer parties'),
    'position' => 'left',
    'file' => 'crm_party.admin.inc',
  );
  // @todo crib from one of the core modules for how this admin menu pattern should be done, eg 'People'.
  $items['admin/community/parties'] = array(
    'title' => 'List',
    'page callback' => 'crm_party_admin',
    'page arguments' => array('list'),
    'access arguments' => array('administer parties'),
    'position' => 'left',
    'file' => 'crm_party.admin.inc',
  );
  $items['admin/community/party/manage'] = array(
    'title' => 'Party admin',
    'description' => 'Manage contact information',
    'page callback' => 'crm_party_info',
    'access arguments' => array('administer parties'),
    'file' => 'crm_party.admin.inc',
  );
  $items['admin/community/party/manage/individual'] = array(
    'title' => 'Manage individuals',
    'description' => 'Manage contact information',
    'page callback' => 'crm_party_manage',
    'page arguments' => array('individual'),
    'access arguments' => array('administer parties'),
    'file' => 'crm_party.admin.inc',
  );
  $items['admin/community/party/manage/organisation'] = array(
    'title' => 'Manage organisations',
    'description' => 'Manage contact information',
    'page callback' => 'crm_party_manage',
    'page arguments' => array('organisation'),
    'access arguments' => array('administer parties'),
    'file' => 'crm_party.admin.inc',
  );
  
  $items['party/%crm_party'] = array(
    'title callback' => 'crm_party_page_title',
    'title arguments' => array(1),
    'page callback' => 'crm_party_page_view',
    'page arguments' => array(1),
    'file' => 'crm_party.pages.inc',
    'access callback' => 'crm_party_access',
    'access arguments' => array('view', 1),
    'type' => MENU_NORMAL_ITEM,
  );

  // Build the party view first-level tabs.
  // @todo: Write a contrib module to turn a set of tabs into ajax tabs,
  // probably using or as part of quicktabs module.
  $pieces = crm_party_get_party_piece_info();
  // These come sorted by weight so we know which to make the default tab.
  foreach ($pieces as $path => $piece) {
    if (!isset($seen_first_piece)) {
      $seen_first_piece = TRUE;
      $piece['type'] = MENU_DEFAULT_LOCAL_TASK;
    }
    // Add in some defaults for convenience.
    // @todo: once these stabilize, document them in the API file.
    $piece += array(
      'type' => MENU_LOCAL_TASK,
      // Make this explicit so it overrides the parent.
      'access callback' => 'user_access',
      'access arguments' => array('view contacts'),
      // @todo: change this to use crm_party_access().
      // we'll need a dataset loader. @see @todo in crm_profile_crm_party_data_set_info().
      //'access arguments' => array('view', 1),
    );
    $items["party/%crm_party/$path"] = $piece;
  }

  // This is temporary until I figure out a neat way to do tabs below pieces.
  $items['party/%crm_party/party/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  ) + $items['party/%crm_party/party'];

  $items['party/%crm_party/party/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('crm_party_edit_form', 1),
    'file' => 'crm_party.pages.inc',
    'access arguments' => array('edit contacts'),
    'type' => MENU_LOCAL_TASK,
  );
  // End temporary.
  
  // Edit data set instance
  $items['party/%crm_party/edit/%/%'] = array(
    'page callback' => 'crm_party_data_set_edit',
    'page arguments' => array(3, 1, 4), //3 Arguments, party then set type then set eid
    'access callback' => TRUE, // todo
    'access arguments' => array('edit contacts'),
    'file' => 'crm_party.pages.inc',
  ); 
  
  // Remove a data set instance
  $items['party/%crm_party/remove/%/%'] = array(
    'page callback' => 'crm_party_data_set_remove',
    'page arguments' => array(3, 1, 4), //3 Arguments, party then set type then set eid
    'access callback' => TRUE, // todo
    'file' => 'crm_party.pages.inc',
  );
  
  // Add a new instance of a data set
  $items['party/%/add/%'] = array(
    'page callback' => 'crm_party_data_set_edit',
    'page arguments' => array(3, 1), // 2 Arguments, party then set type.
    'access callback' => TRUE, // todo
    'access arguments' => array('edit contacts'),
    'file' => 'crm_party.pages.inc',
  );

  $items['party/add'] = array(
    'title' => 'Add party',
    'page callback' => 'crm_party_add',
    'file' => 'crm_party.pages.inc',
    'access arguments' => array('create contacts'),
  );
  $items['party/add/individual'] = array(
    'title' => 'Add individual',
    'page callback' => 'crm_party_add',
    'page arguments' => array('individual'),
    'file' => 'crm_party.pages.inc',
    'access arguments' => array('create contacts'),
  );
  $items['party/add/organisation'] = array(
    'title' => 'Add organisation',
    'page callback' => 'crm_party_add',
    'page arguments' => array('organisation'),
    'file' => 'crm_party.pages.inc',
    'access arguments' => array('create contacts'),
  );

  return $items;
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function crm_party_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Add action link to 'party/add' on 'admin/community/parties' page.
  if ($root_path == 'admin/community/parties') {
    $item = menu_get_item('party/add');
    if ($item['access']) {
      $data['actions']['output'][] = array(
        '#theme' => 'menu_local_action',
        '#link' => $item,
      );
    }
  }

  // Add action links for attaching new entities on party pieces that are built
  // from data sets.
  if (substr($root_path, 0, 8) == 'party/%/') {
    $piece_subpath = arg(2, $root_path);
    $pieces = crm_party_get_party_piece_info();
    $piece = $pieces[$piece_subpath];

    if (isset($piece['data_set'])) {
      $item = menu_get_item('party/%/add/%');
      if ($item['access']) {
        $data_sets = crm_party_get_data_set_info();
        $data_set = $data_sets[$piece['data_set']];
        $data['actions']['output'][] = array(
          '#theme' => 'menu_local_action',
          '#link' => array(
            'title' => t('Attach new @data-set', array('@data-set' => $data_set['label'])),
            // @todo: remove arg(), use menu_get_object().
            'href' => 'party/' . arg(1) . '/add/' . $piece['data_set'],
          ),
        );
      }
    }
  }
}

/**
 * Determines whether the party may attach the given entity.
 *
 * @param $op
 *   The operation being performed.
 * @param $party
 *   A party to check access for.
 * @param $attached_entity
 *   (optional) An attached entity to check access for. If nothing is given,
 *   access for just the party itself is determined.
 * @param $account
 *   The user to check for. Leave it to NULL to check for the global user.
 *
 * @return boolean
 *   Whether access is allowed or not.
 *
 * @see hook_crm_party_access()
 * @see crm_party_crm_party_access()
 */
function crm_party_access($op, $party = NULL, $attached_entity = NULL, $account = NULL) {
  // Let the admin through when there's no attached entity being considered.
  if (!isset($attached_entity) && user_access('administer parties', $account)) {
    return TRUE;
  }

  // Allow modules to grant / deny access.
  $access = module_invoke_all('crm_party_access', $op, $party, $attached_entity, $account);

  // Only grant access if at least one module granted access and no one denied
  // access.
  if (in_array(FALSE, $access, TRUE)) {
    return FALSE;
  }
  elseif (in_array(TRUE, $access, TRUE)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_crm_party_access().
 *
 * WIP: just say yes for now!
 */
function crm_party_crm_party_access($op, $party = NULL, $attached_entity = NULL, $account = NULL) {
  // If we're not being asked about attachments, just use plain permissions.
  if (!isset($attached_entity)) {
    switch ($op) {
      case 'view':
        return user_access('view contacts');
    }
  }

  return TRUE;
}

/**
 * Implements hook_admin_paths().
 */
function crm_party_admin_paths() {
  $paths = array(
    'party/*/edit/*' => TRUE,
    'party/*/remove/*' => TRUE,
    'party/*/add/*' => TRUE,
  );
  return $paths;
}

/**
 * Page title callback for party view page.
 *
 * Has to be in the main module file because it's used by several menu items.
 */
function crm_party_page_title($party) {
  return $party->label;
}

// -----------------------------------------------------------------------
// Party pieces: defining extra hook_menu() items according to data structure.

/**
 * Get all party piece definitions from hook_crm_party_party_pieces().
 *
 * This is only used by hook_menu() and an admin page so no need to cache.
 *
 * @return
 *  An array of party pieces, keyed by path and sorted by weight.
 *  Keys in addition to those defined in hook_crm_party_party_pieces():
 *  - data_set: The id of a data set if this piece is defined from one.
 */
function crm_party_get_party_piece_info() {
  $pieces = module_invoke_all('crm_party_party_pieces');

  // Add in weights from the admin setting.
  $weights = variable_get('crm_party_name_pieces_weights', array());
  foreach ($pieces as $path => $piece) {
    // The weight setting overrides weights defined in the hook.
    if (isset($weights[$path])) {
      $pieces[$path]['weight'] = $weights[$path];
    }
  }

  // Sort pieces array by weight for hook_menu() to figure out the default tab
  // and the admin UI to show them in the right order.
  // drupal_sort_weight() treats a missing weight key as a 0.
  uasort($pieces, 'drupal_sort_weight');

  return $pieces;
}

/**
 * Implements hook_crm_party_party_pieces().
 *
 * Defines:
 *  - the basic piece for showing a party itself
 *  - pieces that data sets provide
 *  - pieces provided by Views as display plugins.
 */
function crm_party_crm_party_party_pieces() {
  $pieces = array(
    // The main party piece.
    // By default this is the default tab, but the MENU_DEFAULT_LOCAL_TASK
    // is supplied in hook_menu() to allow the piece order setting to change
    // the default tab accordingly.
    'party' => array(
      'title' => 'Party',
      'page callback' => 'crm_party_page_view',
      'page arguments' => array(1),
      'file' => 'crm_party.pages.inc',
      'access arguments' => array('view contacts'),
      'weight' => -10,
    ),
  );

  // Party data sets may provide a piece each.
  $sets = crm_party_get_data_set_info();
  foreach ($sets as $set_name => $set) {
    if (isset($set['piece'])) {
      // The path becomes the piece's key.
      $path = $set['piece']['path'];
      unset($set['piece']['path']);
      // Add a key to say we came from a dataset.
      $set['piece']['data_set'] = $set_name;

      $pieces[$path] = $set['piece'];
    }
  }

  // Custom pieces can be created as Views plugins.
  if (module_exists('views')) {
    // Get all views displays that implement our hook.
    // There's no need to cache: views_menu() doesn't cache for page displays.
    $views = views_get_all_views();
    foreach ($views as $view) {
      // Disabled views get nothing.
      if (!empty($view->disabled)) {
        continue;
      }

      $view->init_display();
      foreach ($view->display as $display_id => $display) {
        if (isset($display->handler) && !empty($display->handler->definition['uses hook crm_party_party_pieces'])) {
          $result = $display->handler->execute_hook_crm_party_party_pieces();
          if (is_array($result)) {
            $pieces = array_merge($pieces, $result);
          }
        }
      }
    }
  }

  return $pieces;
}

// -----------------------------------------------------------------------
// API for getting and changing data sets.

/**
 * Get the attached entity controller.
 *
 * @param $data_set_name
 *  The name of the $set definition.
 */
function crm_party_get_crm_controller($data_set_name) {
  $sets = crm_party_get_data_set_info();

  // @todo: error handling
  $class = $sets[$data_set_name]['class'];
  return new $class($data_set_name);
}

/**
 * Get the data set definition associated with a given entity and bundle.
 *
 * @param $entity_type
 *  The entity type e.g profile2 etc.
 * @param $entity
 *  The entity object or id.
 *
 * @return
 *  A data set name if one exists, NULL otherwise.
 */
function crm_party_get_entity_data_set($entity_type, $entity) {
  $data_set_info = crm_party_get_data_set_info();

  // Get bundle.
  $info = entity_get_info($entity_type);
  $bundle_key = empty($info['entity keys']['bundle']) ? FALSE : $info['entity keys']['bundle'];

  if (!$bundle_key) {
    $bundle = $entity_type;
  }
  else {
    $bundle = $entity->{$bundle_key};
  }

  foreach ($data_set_info as $data_set_name => $data_set) {
    if ($data_set['entity type'] == $entity_type && $data_set['entity bundle'] == $entity->type) {
      return $data_set_name;
    }
  }

  return NULL;
}

/**
 * Get all data sets from hook_crm_party_data_set_info().
 *
 * @todo: cache this, either in the DB or using DrupalCacheArray.
 *
 * @param $data_set_name
 *  (optional) The name of the data set to return. If omitted, all are returned.
 *
 * @return
 *  Either a single data set, or an array of data sets keyed by set name.
 *  Each set is an array whose keys are as returned by
 *  hook_crm_party_data_set_info(), with in addition:
 *  - 'module': The module defining this set.
 *  - 'table': The table in which this set's data is stored.
 */
function crm_party_get_data_set_info($data_set_name = NULL) {
  // Due to http://drupal.org/node/890660 we can't use module_invoke_all()
  // because we need to know the provenance of each set.
  $sets = array();
  foreach (module_implements('crm_party_data_set_info') as $module) {
    $sets_module = module_invoke($module, 'crm_party_data_set_info');
    foreach ($sets_module as $set_name => $set) {
      // Add in some essential data we need, but allow modules to set this too.
      $set += array(
        'module' => $module,
        // It would be nice to make either crm_party_data_set_schema_template()
        // or this function the single canonical place in which the table name
        // is derived from the set name. But hook_views_data() doesn't want to
        // be messing with a schema, and crm_party_modules_uninstalled()
        // doesn't want to call this.
        'table'  => 'crm_party_set_' . $set_name,
        'singleton' => FALSE,
      );
      $sets[$set_name] = $set;
    }
  }

  if (isset($data_set_name)) {
    return $sets[$data_set_name];
  }
  else {
    return $sets;
  }
}

/**
 * Add a new Party data set.
 *
 * This adds a table to the database to handle relationships from parties to
 * data sets. This should only be called by modules that need to dynamically
 * add data sets. They should be declared in hook_crm_party_data_set_info()
 * in all cases.
 *
 * @see hook_crm_party_data_set_info().
 *
 * @param $set_name
 *  The machine name of the data set.
 */
function crm_party_data_set_type_add($set_name) {
  module_load_install('crm_party');
  $schema = crm_party_data_set_schema_template($set_name);
  // This is ugly as it's always a singleton array.
  // @todo clean this up with a helper function that gets all the schemas
  // for a list of sets?
  foreach ($schema as $name => $table) {
    db_create_table($name, $table);
  }
}

/**
 * Remove a Party data set.
 *
 * @see hook_crm_party_data_set_info().
 * @see crm_party_data_set_type_add().
 */
function crm_party_data_set_type_remove($set_name) {
  module_load_install('crm_party');
  $schema = crm_party_data_set_schema_template($set_name);
  // This is ugly as it's always a singleton array.
  // @todo clean this up with a helper function that gets all the schemas
  // for a list of sets?
  foreach ($schema as $name => $table) {
    db_drop_table($name);
  }
}

/**
 * Implements hook_modules_uninstalled().
 *
 * (Note this has to be in the module file not the install file.)
 *
 * Drop the tables created for relations for the data sets provided by
 * modules being uninstalled.
 */
function crm_party_modules_uninstalled($modules) {
  $sets = array();
  foreach ($modules as $module) {
    // During uninstall we need to load module files.
    drupal_load('module', $module);
    if (module_hook($module, 'crm_party_data_set_info')) {
      $sets += module_invoke($module, 'crm_party_data_set_info');
    }
  }

  drupal_load('module', 'crm_party');
  foreach ($sets as $set_name => $set) {
    crm_party_data_set_type_remove($set_name);
  }
}

// -----------------------------------------------------------------------
// API for relating and unrelating entities to a party.

/**
 * Attach an entity to a party according to a given data set.
 *
 * @param $party
 *  The party to assign the entity to.
 * @param $entity
 *  The entity to relate to.
 * @param $data_set
 *  The name of the data set.
 *  DX WTF: can we sniff this out given the entity type and the entity object?
 *  DX WTF: Lots of sniffing now done BUT do we want the $data_set instance made elsewhere. If so where?
 */
function crm_party_relate($party, $entity, $data_set) {
  $sets = crm_party_get_data_set_info();
  $class = $sets[$data_set]['class'];
  $dataSet = new $class($data_set, $entity);
  $dataSet->attach($party);
}

/**
 * Detach an entity from a party according to a given data set.
 *
 * @param $party
 *  The party to detach the entity from.
 * @param $entity
 *  The entity to detach. This may also be just the entity id.
 * @param $data_set
 *  The name of the data set.
 *  DX WTF: can we sniff this out given the entity type and the entity object?
 */
function crm_party_unrelate($party, $entity, $data_set) {
  /* To Test */
  $sets = crm_party_get_data_set_info();
  $class = $sets[$data_set]['class'];
  $dataSet = new $class($data_set, $entity, $party); 
  $dataSet->detach();
}

// -----------------------------------------------------------------------
// API for loading data about a party.

/**
 * Return all attached entities of a particular set.
 *
 * @param $party
 *  The party object of the party we're concerned with.
 * @param $set_name
 *  The set type as defined in hook_crm_party_data_set_info().
 *
 * @return
 *  An array of the attached entity controllers for the entities attached to the
 *  party in the given data set, keyed by entity id.
 *  Each entity additionally has the property 'crm_party_main' set according
 *  to the 'main' flag in the data set.
 *  @todo fix the hash this is indexed by!
 */
function crm_party_get_attached_entities($party, $data_set_name) {
  $sets = crm_party_get_data_set_info();
  //dsm($sets);

  $items = db_select('crm_party_attached_entity', 'ds')
    ->fields('ds')
    ->condition('pid', $party->pid,'=')
    ->condition('data_set', $data_set_name,'=')
    ->execute()
    ->fetchAllAssoc('eid', PDO::FETCH_ASSOC);
    
  $attached_entities = array();

  foreach ($items as $eid => $instance) {
    $attached_entity = crm_party_get_crm_controller($data_set_name);
    $attached_entity->setParty($party);
    $attached_entity->setAttachedEntity($eid);
    $attached_entities[$attached_entity->hash()] = $attached_entity;
  }
  
  return $attached_entities;
}

/**
 * Get the form for a data set (more to the point get a set of fields for the data set
 * might need to work on this).
 *
 * @param $party The party object of the party we're concerned with
 * @param $set_type The set type as defined in hook_data_set_info
 * @param $set_id The set id as stored in the related table
 *
 * @return
 *   A form array.
 */
function crm_party_data_set_form($party, $set_type, $set_id = FALSE) {
  $sets = crm_party_get_data_set_info();
  $function = $sets[$set_type]['form callback'];
  if (function_exists($function)) {
    $result = call_user_func($function, $party, $set_type, $set_id);
  }
  else {
    return FALSE;
  }
  return $result;
}

/**
 * Attach a data set to a party (or edit the attachment?)
 *
 * @param $party the party object
 * @param $set_type The set type as defined in hook_data_set_info
 * @param $set_id The set id as stored in the related table
 * @param $main Is this the main set of this type
 * @param $hat Not used yet
 * @param $hat_main Not used yet
 */
function crm_party_data_set_instance_attach($party, $set_type, $set_id, $main = FALSE, $hat = '', $hat_main = FALSE, $null = FALSE) {
  $data = array(
    'pid' => $party->pid,
    'sid' => $set_id,
    'main' => $main,
    'hat' => $hat,
    'hat_main' => $hat_main,
    'null' => $null,
  );

  drupal_write_record('crm_party_data_set_' . $set_type, $data);
}

/**
 * Unattach a data set from a party
 *
 * @param $party the party object
 * @param $set_type The set type as defined in hook_data_set_info
 * @param $set_id The set id as stored in the related table
 *
 * @todo Implement
 */
function crm_party_data_set_instance_detach($party, $set_type, $set_id) {
  return TRUE;
}

/**
 * Get party piece instances
 *
 * @param $parent
 *  Id of the parent party piece
 * @param $party_type
 *  The party type we're looking at
 * @param $party_piece
 *  (optional) the Piece we're looking for
 */
function crm_party_get_party_piece_instances($parent, $party_type, $party_pieces = NULL) {
  // Build the query;
  $query = db_select('crm_party_party_pieces', 'pp');
  $query->fields('pp');
  $query->condition('parent_id', $parent, '=');
  if (is_array($party_pieces)) {
    $query->condition('party_piece', $party_pieces, 'IN');
  }
  $query->condition('party_type', $party_type, '=');
  $query->orderBy('weight');

  // Get all the results that fit
  $results = $query->execute()->fetchAllAssoc('instance_id');
  foreach ($results as $key => $result) {
    // Decode the arguments into a useable form.
    $results[$key]['arguments'] = json_decode($result['arguments'], TRUE);
  }
  return $results;
}

/**
 * Add a new party piece instance
 * 
 * @param $instance array of all values needed for this instance
 */
function crm_party_save_party_piece_instance($instance = array()) {
  //Do checks to make sure everthing is there
  
  //Encode arguments
  $instance['arguments'] = json_encode($instance['arguments']);
  
  //If the $instance['instance_id'] is set, we're updating.
  if (isset($instance['instance_id'])) {
    $id = $instance['instance_id'];
    unset($instance['instance_id']);
    drupal_write_record('crm_party_party_pieces', $instance, $id);
  }
  else {
    drupal_write_record('crm_party_party_pieces', $instance);
  }
}

/**
 * Delete a party piece instance
 *
 * @param $instance integer id of the instance to delete
 *
 * @return True on success, False on failure
 * @todo: implement
 */
function crm_party_delete_party_piece_instance($instance) {
  return TRUE;
} 

/**
 * Display a party piece
 *
 * @param $party the party object we're looking at
 * @param $instance the instance of a party piece either an id or associative array
 *   (one row from crm_party_get_party_pieces);
 *
 * @todo workout something to do with permissions
 * @todo
 */
function crm_party_party_piece_display($party, $instance) {
  if (is_numeric($instance)) {
    // Build the query;
    $query = db_select('crm_party_party_pieces', 'pp');
    $query->fields('pp');
    $query->condition('instance_id', $instance, '=');
    // Get the row
    $result = $query->execute()->fetchAssoc();
    $result['arguments'] = json_decode($result['arguments'], true);
    $instance = $result;
  }

  //Call the display function
  $pieces = crm_party_party_piece_info();
  $function = $pieces[$instance['party_piece']]['display callback'];

  if (function_exists($function)) {
    $result = call_user_func($function, $party, $instance, $instance['title'], $instance['arguments']);
  }
  else {
    return FALSE;
  }

  //If the Party Piece can have children, load those children
  if ($pieces[$instance['party_piece']]['nesting']) {
    $result += crm_party_party_piece_display_children($party, $instance);
  }

  return $result;
}

/**
 * display the children party pieces
 *
 * @param $party The party we're looking at.
 * @param $instance The instance of the parent.
 *
 * @return
 *    An array of renderable arrays keyed by "child_piece_<child_instance_id>"
 *
 * @todo Implement. Use crm_party_get_party_pieces. And crm_party_piece_display.
 */
function crm_party_party_piece_display_children($party, $instance) {
  return array();
}

/**
 * Display a tab
 *
 * @todo Implement. Use crm_party_party_piece_display_children() to get hte children of the tab.
 */
function crm_party_party_piece_tab_display($party, $instance, $title, $arguments) {
  return array();
}

/**
 * Implements hook_permission().
 */
function crm_party_permission() {
  return array(
    'administer crm settings' => array(
      'title' => t('Administer CRM settings'),
      'restrict access' => TRUE,
    ),
    'administer party types' => array(
      'title' => t('Administer party types'),
      'restrict access' => TRUE,
    ),
    'administer parties' =>  array(
      'title' => t('Administer parties'),
      'restrict access' => TRUE,
    ),
    'create parties' => array(
      'title' => t('Create parties'),
    ),
    'view parties' => array(
      'title' => t('View parties'),
    ),
    'edit parties' => array(
      'title' => t('Edit parties'),
    )
  );
}

/**
 * URI callback for contacts.
 */
function crm_party_uri($party) {
  return array('path' => 'party/' . $party->pid, );
}

/**
 * Implements hook_theme().
 */
function crm_party_theme() {
  return array(
    'crm_party_settings_pieces_order_form' => array(
      'render element' => 'form',
    ),
    'crm_party_email' => array(
      'variables' => array('crm_party_email', 'crm_party' => NULL),
      'template' => 'crm_party_email',
    ),
    'entity__all__party' => array(
      'render element' => 'elements',
      'template' => 'entity--all--party',
      'path' => drupal_get_path('module', 'crm_party') . '/theme',
    ),
  );
}

/**
 * Implements hook_preprocess_HOOK().
 *
 * Add our own template for party display.
 */
function crm_party_preprocess_entity(&$variables) {
  if ($variables['view_mode'] == 'party') {
    $entity_type  = $variables['entity_type'];
    $entity       = $variables['elements']['#entity'];
    list($eid, ) = entity_extract_ids($entity_type, $entity);

    //dsm($variables);
    $party_id = $entity->crm_attaching_party;

    // @todo: clean this up -- having to load up the controller all over
    // again when we probably had it at some earlier point is just messy.
    $data_set_name = crm_party_get_entity_data_set($entity_type, $entity);
    $crm_controller = crm_party_get_crm_controller($data_set_name, $party_id);
    $crm_controller->setParty($party_id);
    $crm_controller->setAttachedEntity($eid);
    //dsm($crm_controller);

    // Add the attached entity actions to the build content.
    $variables['content']['crm_party_actions'] = array(
      '#theme' => 'links',
      '#links' => $crm_controller->actions(),
      '#attributes' => array(
        'class' => array('links inline crm-set-action-links'),
      ),
      '#weight' => 100,
    );

    // @todo This would be better off as a new feature in Entity API
    $variables['theme_hook_suggestions'][] = 'entity__all__party';
    // @todo Hmmmm how do we let hook_theme() know about this?
    $variables['theme_hook_suggestions'][] = 'entity__' . $entity_type . '__all__party';
  }
}

/**
 * Load a party entity from the database.
 *
 * @param $pid
 *  The party ID.
 * @param $reset
 *  Whether to reset the crm_party_load_multiple cache.
 *
 * @return
 *   A party object.
 */
function crm_party_load($pid = NULL, $reset = FALSE) {
  $pids = (isset($pid) ? array($pid) : array());
  $party = crm_party_load_multiple($pids, $reset);
  return $party ? reset($party) : FALSE;
}

/**
 * Load party entities from the database.
 *
 * @param $pids
 *  An array of party IDs.
 * @param $conditions
 *   (deprecated) An associative array of conditions on the {crm_party}
 *   table, where the keys are the database fields and the values are the
 *   values those fields must have. Instead, it is preferable to use
 *   EntityFieldQuery to retrieve a list of entity IDs loadable by
 *   this function.
 * @param $reset
 *   Whether to reset the cache.
 *
 * @return
 *   An array of party objects indexed by nid.
 */
function crm_party_load_multiple($pids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('crm_party', $pids, $conditions, $reset);
}

/**
 * Delete a party.
 */
function crm_party_delete(CRMParty $party) {
  $party->delete();
}

/**
 * Save a crm_party.
 *
 *  @param $party
 *
 */
function crm_party_save(&$party) {
  return entity_get_controller('crm_party')->save($party);
}

/**
 * Create a crm_party object ready for saving to the database.
 *
 * @param $info
 *  An array carrying all the important information.
 *
 * @return
 *  A party object that can be passed to crm_party_save().
 */
function crm_party_create($info) {
  if (!is_array($info)) {
    return FALSE;
  }
  if (!isset($info['type'])) {
    return FALSE;
  }

  return (object) $info;
}

/**
 * Implements hook_party_operations.
 */
function crm_party_party_operations() {
  $operations = array(
    'merge' => array(
      'label' => t('Merge parties'),
      'callback' => 'crm_party_party_operations_merge',
    ),
  );
  return $operations;
}

/**
 * Merge multiple users.
 */
function crm_party_party_operations_merge($parties) {
  // @todo: write me!
}

// -----------------------------------------------------------------------
// Views hook implementations.

/**
 * Implements hook_views_api().
 */
function crm_party_views_api() {
  return array(
    'api' => '3.0-alpha1',
    'path' => drupal_get_path('module', 'crm_party') . '/includes/views',
  );
}

// -----------------------------------------------------------------------
// CTools hook implementations.

/**
 * Implements hook_ctools_plugin_type().
 *
 * Declare the plugin types we invent.
 */
function crm_party_ctools_plugin_type() {
  // Party name label plugins provide ways to generate a party name label
  // from a party.
  $plugins['party_name_label'] = array(
  );

  return $plugins;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function crm_party_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'crm_party') {
    return "plugins/$plugin_type";
  }
}

// --------------------------------------------------------------------------
// CRM Party Attached Entity Form API

/**
 * Get the form callback for attached entities.
 */
function crm_party_attached_entity_form_callback($data_set) {
  $sets = crm_party_get_data_set_info();
  return $sets[$data_set]['form callback'];
}

/**
 * Attach attached entity forms to a form.
 */
function crm_party_attached_entity_attach_form(&$form, &$form_state) {
  // Get all attached entities from $form_state.
  $attached_entities = $form_state['#attached_entities'];

  foreach ($attached_entities as $hash => $attached_entity) {
    // Get the form callback.
    $callback = crm_party_attached_entity_form_callback($attached_entity->data_set_name);
    // Execute the form callback.
    $form[$hash] =  $callback($form, $form_state, $attached_entity, $form_state['#party']);
    $form[$hash]['#type'] = 'fieldset';
    $form[$hash]['#title'] = $attached_entity->getLabel();
    $form[$hash]['#tree'] = TRUE;
  }

  $form['#submit'][] = 'crm_party_attached_entity_attach_form_submit';
  $form['#validate'][] = 'crm_party_attached_entity_attach_form_validate';
}

/**
 * Validate attached entity forms.
 */
function crm_party_attached_entity_attach_form_validate(&$form, &$form_state) {
  return TRUE;
}

/**
 * Submit attached entity forms
 */
function crm_party_attached_entity_attach_form_submit(&$form, &$form_state) {
  // Get all attached entities from $form_state.
  $attached_entities = $form_state['#attached_entities'];
  $party = $form_state['#party'];

  foreach ($attached_entities as $hash => $attached_entity) {
    /// @todo explain what $hash is.
    // Get the form callback.
    $callback = crm_party_attached_entity_form_callback($attached_entity->data_set_name) . '_submit';
    // Execute the form callback.
    dsm($callback);
    $callback($form, $form_state, $attached_entity, $form_state['#party']);

    $attached_entity->attach($party);
    dsm($attached_entity);
  }
}
