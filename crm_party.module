<?php

/**
 * @file
 * Provides a generic CRM party entity.
 */

// @todo: If these contain only classes they will be autoloaded and these include statements can be dropped.
include_once("includes/crm_party.entity.inc");
include_once("includes/crm_party_type.entity.inc");
include_once("crm_party.data_set.inc");

/**
 * Implements hook_help().
 */
function crm_party_help($path, $arg) {
  switch ($path) {
    case 'admin/help#crm_party':
      return t("TODO: Create admin help text.");
    case 'admin/config/crm/labels':
      return t("Party name label generators save a label whenever a party is created or updated. This lets you form the party's label or name in a variety of methods.");
  }
}

/**
 * Implements hook_entity_info().
 *
 * Define 2 entities here - the actual entity that will hold our domain
 * specific information and an entity that holds information about the
 * different types of entities.
 */
function crm_party_entity_info() {
  $party_info['crm_party'] = array(
    'label' => t('Party'),
    'entity class' => 'CRMParty',
    'controller class' => 'CRMPartyController',
    // We define this so entity module provides us with basic Views data, while
    // allowing us to define more of our own.
    // See http://drupal.org/node/1307760.
    'views controller class' => 'EntityDefaultViewsController',
    'base table' => 'crm_party',
    //'uri callback' => 'crm_party_uri',
    'fieldable' => TRUE,
    'module' => 'crm_party',
    'entity keys' => array(
      'id' => 'pid',
      'bundle' => 'type',
    ),
    'exportable' => TRUE,
    //'static cache' => TRUE,
    'bundles' => array(
      'individual' => array(
        'label' => t('Individual Party'),
        'admin' => array(
          'path' => 'admin/community/party/manage/individual',
          'access arguments' => array('administer parties'),
        ),
      ),
      'organisation' => array(
        'label' => t('Organisation Party'),
        'admin' => array(
          'path' => 'admin/community/party/manage/organisation',
          'access arguments' => array('administer parties'),
        ),
      ),
    ),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full Contact'),
        'custom settings' =>  FALSE,
      ),
    )
  );

  return $party_info;
}

/**
 * Implements hook_entity_info_alter().
 *
 * We are adding the info about the model types via a hook to avoid a recursion
 * issue as loading the model types requires the entity info as well.
 *
 * @todo This needs to be improved
 *
function crm_party_entity_info_alter(&$entity_info) {
  foreach (crm_party_get_types() as $type => $info) {
    $entity_info['crm_party']['bundles'][$type] = array(
      'label' => $info->label,
      'admin' => array(
        'path' => 'admin/community/structure/party_types/manage/%crm_party_type',
        'real path' => 'admin/community/structure/party_types/manage/' . $type,
        'bundle argument' => 4,
        'access arguments' => array('administer party types'),
      ),
    );
  }
}
*/

/**
 * Implements hook_menu().
 */
function crm_party_menu() {
  // CRM settings.
  // Making up a new config category.
  // Alternative is to put this all under top-level admin.
  // But all this structure is rough anyway.
  $items['admin/config/crm'] = array(
    'title' => 'CRM',
    'description' => 'CRM settings.',
    'position' => 'left',
    'weight' => -10,
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('access administration pages'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );
  $items['admin/config/crm/labels'] = array(
    'title' => 'Labels',
    'description' => 'Determine how labels for parties are generated.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('crm_party_settings_label_plugin_form'),
    'access arguments' => array('administer crm settings'),
    'file' => 'crm_party.admin.inc',
  );
  $items['admin/config/crm/piece-order'] = array(
    'title' => 'Piece order',
    'description' => 'Rearrange the order of pieces within a party.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('crm_party_settings_pieces_order_form'),
    'access arguments' => array('administer crm settings'),
    'file' => 'crm_party.admin.inc',
  );

  $items['admin/community'] = array(
    'title' => 'Community',
    'description' => 'Manage the community',
    'page callback' => 'crm_party_admin',
    'page arguments' => array('list'),
    'access arguments' => array('administer parties'),
    'position' => 'left',
    'file' => 'crm_party.admin.inc',
  );
  // @todo crib from one of the core modules for how this admin menu pattern should be done, eg 'People'.
  $items['admin/community/parties'] = array(
    'title' => 'List',
    'page callback' => 'crm_party_admin',
    'page arguments' => array('list'),
    'access arguments' => array('administer parties'),
    'position' => 'left',
    'file' => 'crm_party.admin.inc',
  );
  $items['admin/community/party/manage'] = array(
    'title' => 'Party admin',
    'description' => 'Manage contact information',
    'page callback' => 'crm_party_info',
    'access arguments' => array('administer parties'),
    'file' => 'crm_party.admin.inc',
  );
  $items['admin/community/party/manage/individual'] = array(
    'title' => 'Manage individuals',
    'description' => 'Manage contact information',
    'page callback' => 'crm_party_manage',
    'page arguments' => array('individual'),
    'access arguments' => array('administer parties'),
    'file' => 'crm_party.admin.inc',
  );
  $items['admin/community/party/manage/organisation'] = array(
    'title' => 'Manage organisations',
    'description' => 'Manage contact information',
    'page callback' => 'crm_party_manage',
    'page arguments' => array('organisation'),
    'access arguments' => array('administer parties'),
    'file' => 'crm_party.admin.inc',
  );

  $items['party/%crm_party'] = array(
    'title callback' => 'crm_party_page_title',
    'title arguments' => array(1),
    'page callback' => 'crm_party_page_view',
    'page arguments' => array(1),
    'file' => 'crm_party.pages.inc',
    'access arguments' => array('view contacts'),
    'type' => MENU_NORMAL_ITEM,
  );

  // Build the party view first-level tabs.
  // @todo: Write a contrib module to turn a set of tabs into ajax tabs,
  // probably using or as part of quicktabs module.
  $pieces = crm_party_get_party_piece_info();
  // These come sorted by weight so we know which to make the default tab.
  foreach ($pieces as $path => $piece) {
    if (!isset($seen_first_piece)) {
      $seen_first_piece = TRUE;
      $piece['type'] = MENU_DEFAULT_LOCAL_TASK;
    }
    // Add in some defaults for convenience.
    // @todo: once these stabilize, document them in the API file.
    $piece += array(
      'type' => MENU_LOCAL_TASK,
      'access arguments' => array('view contacts'),
    );
    $items["party/%crm_party/$path"] = $piece;
  }

  // This is temporary until I figure out a neat way to do tabs below pieces.
  $items['party/%crm_party/party/view'] = $items['party/%crm_party/party'];
  $items['party/%crm_party/party/view'] += array(
    'title' => t('View'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['party/%crm_party/party/edit'] = array(
    'title' => t('Edit'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('crm_party_edit_form', 1),
    'file' => 'crm_party.pages.inc',
    'access arguments' => array('edit contacts'),
    'type' => MENU_LOCAL_TASK,
  );
  // End temporary.

  $items['party/add'] = array(
    'title' => 'Add party',
    'page callback' => 'crm_party_add',
    'file' => 'crm_party.pages.inc',
    'access arguments' => array('create contacts'),
  );
  $items['party/add/individual'] = array(
    'title'=> 'Add individual',
    'page callback' => 'crm_party_add',
    'page arguments' => array('individual'),
    'file' => 'crm_party.pages.inc',
    'access arguments' => array('create contacts'),
  );
  $items['party/add/organisation'] = array(
    'title' => 'Add organisation',
    'page callback' => 'crm_party_add',
    'page arguments' => array('organisation'),
    'file' => 'crm_party.pages.inc',
    'access arguments' => array('create contacts'),
  );

  return $items;
}

// -----------------------------------------------------------------------
// Party pieces: defining extra hook_menu() items according to data structure.

/**
 * Get all party piece definitions from hook_crm_party_party_pieces().
 *
 * This is only used by hook_menu() and an admin page so no need to cache.
 *
 * @return
 *  An array of party pieces, keyed by path and sorted by weight.
 */
function crm_party_get_party_piece_info() {
  $pieces = module_invoke_all('crm_party_party_pieces');

  // Add in weights from the admin setting.
  $weights = variable_get('crm_party_name_pieces_weights', array());
  foreach ($pieces as $path => $piece) {
    // The weight setting overrides weights defined in the hook.
    if (isset($weights[$path])) {
      $pieces[$path]['weight'] = $weights[$path];
    }
  }

  // Sort pieces array by weight for hook_menu() to figure out the default tab
  // and the admin UI to show them in the right order.
  // drupal_sort_weight() treats a missing weight key as a 0.
  uasort($pieces, 'drupal_sort_weight');

  return $pieces;
}

/**
 * Implements hook_crm_party_party_pieces().
 *
 * Defines:
 *  - the basic piece for showing a party itself
 *  - pieces that data sets provide
 *  - pieces provided by Views as display plugins.
 */
function crm_party_crm_party_party_pieces() {
  $pieces = array(
    // The main party piece.
    // By default this is the default tab, but the MENU_DEFAULT_LOCAL_TASK
    // is supplied in hook_menu() to allow the piece order setting to change
    // the default tab accordingly.
    'party' => array(
      'title' => 'Party',
      'page callback' => 'crm_party_page_view',
      'page arguments' => array(1),
      'file' => 'crm_party.pages.inc',
      'access arguments' => array('view contacts'),
      'weight' => -10,
    ),
  );

  // Party data sets may provide a piece each.
  $sets = crm_party_get_data_set_info();
  foreach ($sets as $set_name => $set) {
    if (isset($set['piece'])) {
      $path = $set['piece']['path'];
      unset($set['piece']['path']);
      $pieces[$path] = $set['piece'];
    }
  }

  // Custom pieces can be created as Views plugins.
  if (module_exists('views')) {
    // Get all views displays that implement our hook.
    // There's no need to cache: views_menu() doesn't cache for page displays.
    $views = views_get_all_views();
    foreach ($views as $view) {
      // Disabled views get nothing.
      if (!empty($view->disabled)) {
        continue;
      }

      $view->init_display();
      foreach ($view->display as $display_id => $display) {
        if (isset($display->handler) && !empty($display->handler->definition['uses hook crm_party_party_pieces'])) {
          $result = $display->handler->execute_hook_crm_party_party_pieces();
          if (is_array($result)) {
            $pieces = array_merge($pieces, $result);
          }
        }
      }
    }
  }

  return $pieces;
}

// -----------------------------------------------------------------------
// API for getting and changing data sets.

/**
 * Get all data sets from hook_crm_party_data_set_info().
 *
 * @todo: cache this, either in the DB or using DrupalCacheArray.
 *
 * @return
 *  An array of data sets, keyed by set name. Each set is an array whose keys
 *  are as returned by hookcrm_party_data_set_info(), with in addition:
 *  - 'module': The module defining this set.
 *  - 'table': The table in which this set's data is stored.
 */
function crm_party_get_data_set_info() {
  // Due to http://drupal.org/node/890660 we can't use module_invoke_all()
  // because we need to know the provenance of each set.
  $sets = array();
  foreach (module_implements('crm_party_data_set_info') as $module) {
    $sets_module = module_invoke($module, 'crm_party_data_set_info');
    foreach ($sets_module as $set_name => $set) {
      // Add in some essential data we need, but allow modules to set this too.
      $set += array(
        'module' => $module,
        // It would be nice to make either crm_party_data_set_schema_template()
        // or this function the single canonical place in which the table name
        // is derived from the set name. But hook_views_data() doesn't want to
        // be messing with a schema, and crm_party_modules_uninstalled()
        // doesn't want to call this.
        'table'  => 'crm_party_set_' . $set_name,
        'singleton' => FALSE,
      );
      $sets[$set_name] = $set;
    }
  }
  return $sets;
}

/**
 * Add a new Party data set.
 *
 * This adds a table to the database to handle relationships from parties to
 * data sets. This should only be called by modules that need to dynamically
 * add data sets. They should be declared in hook_crm_party_data_set_info()
 * in all cases.
 *
 * @see hook_crm_party_data_set_info().
 *
 * @param $set_name
 *  The machine name of the data set.
 */
function crm_party_data_set_type_add($set_name) {
  module_load_install('crm_party');
  $schema = crm_party_data_set_schema_template($set_name);
  // This is ugly as it's always a singleton array.
  // @todo clean this up with a helper function that gets all the schemas
  // for a list of sets?
  foreach ($schema as $name => $table) {
    db_create_table($name, $table);
  }
}

/**
 * Remove a Party data set.
 *
 * @see hook_crm_party_data_set_info().
 * @see crm_party_data_set_type_add().
 */
function crm_party_data_set_type_remove($set_name) {
  module_load_install('crm_party');
  $schema = crm_party_data_set_schema_template($set_name);
  // This is ugly as it's always a singleton array.
  // @todo clean this up with a helper function that gets all the schemas
  // for a list of sets?
  foreach ($schema as $name => $table) {
    db_drop_table($name);
  }
}

// -----------------------------------------------------------------------
// API for relating and unrelating entities to a party.

/**
 * Attach an entity to a party according to a given data set.
 *
 * @param $party
 *  The party to assign the entity to.
 * @param $entity
 *  The entity to relate to.
 * @param $data_set
 *  The name of the data set.
 *  DX WTF: can we sniff this out given the entity type and the entity object?
 *  DX WTF: Lots of sniffing now done BUT do we want the $data_set instance made elsewhere. If so where?
 */
function crm_party_relate($party, $entity, $data_set = NULL) {
  /* To Test */
  $sets = crm_party_get_data_set_info();
  $class = $sets[$data_set]['class'];
  $dataSet = new $class($data_set, $entity);
  $dataSet->attach($party);
  dsm($dataSet);
}

/**
 * Detach an entity from a party according to a given data set.
 *
 * @param $party
 *  The party to detach the entity from.
 * @param $entity
 *  The entity to detach. This may also be just the entity id.
 * @param $entity_type
 *  Needed until http://drupal.org/node/1042822 is fixed.
 * @param $data_set
 *  The name of the data set.
 *  DX WTF: can we sniff this out given the entity type and the entity object?
 */
function crm_party_unrelate($party, $entity, $entity_type, $data_set) {
  // Allow the entity to be just an id.
  if (is_numeric($entity)) {
    $eid = $entity;
  }
  else {
    $entity_type_info = entity_get_info($entity_type);
    $entity_id_key = $entity_type_info['entity keys']['id'];
    $eid = $entity->{$entity_id_key};
  }

  // @todo write me
  $table = 'crm_party_set_' . $data_set;

  $num_deleted = db_delete($table)
    ->condition('pid', $party->pid)
    ->condition('eid', $eid)
    ->execute();
}

// -----------------------------------------------------------------------
// API for loading data about a party.

/**
 * Load a data set
 *
 * @param $party
 *  The party object of the party we're concerned with.
 * @param $set_name
 *  The set type as defined in hook_crm_party_data_set_info().
 *
 * @return
 *  An array of the entities attached to the party in the given data set,
 *  keyed by entity id.
 *  Each entity additionally has the property 'crm_party_main' set according
 *  to the 'main' flag in the data set.
 */
function crm_party_data_set_load($party, $set_name) {
  $sets = crm_party_get_data_set_info();
  //dsm($sets);

  $table = db_escape_table($sets[$set_name]['table']);
  $result = db_query("SELECT eid, main FROM {$table} WHERE pid = :pid", array(
    ':pid' => $party->pid,
  ));
  $items = $result->fetchAllAssoc('eid', PDO::FETCH_ASSOC);

  // Load the entities.
  $entities = entity_load($sets[$set_name]['entity type'], array_keys($items));

  // Add our main flag.
  foreach ($entities as $id => $entity) {
    $entity->crm_party_main = (bool) $items[$id]['main'];
  }
  //dsm($entities);

  return $entities;

  /*
  $function= $sets[$set_type]['load callback'];
  if (function_exists($function)) {
    $result = call_user_func($function, $party, $set_type, $set_id);
  }
  else {
    return FALSE;
  }
  return $result;
  */
}

/**
 * Get the form for a data set (more to the point get a set of fields for the data set
 * might need to work on this).
 *
 * @param $party The party object of the party we're concerned with
 * @param $set_type The set type as defined in hook_data_set_info
 * @param $set_id The set id as stored in the related table
 *
 * @return
 *   A form array.
 */
function crm_party_data_set_form($party, $set_type, $set_id = FALSE) {
  $sets = crm_party_get_data_set_info();
  $function = $sets[$set_type]['form callback'];
  if (function_exists($function)) {
    $result = call_user_func($function, $party, $set_type, $set_id);
  }
  else {
    return FALSE;
  }
  return $result;
}

/**
 * Attach a data set to a party (or edit the attachment?)
 *
 * @param $party the party object
 * @param $set_type The set type as defined in hook_data_set_info
 * @param $set_id The set id as stored in the related table
 * @param $main Is this the main set of this type
 * @param $hat Not used yet
 * @param $hat_main Not used yet
 */
function crm_party_data_set_instance_attach($party, $set_type, $set_id, $main = false, $hat = '', $hat_main = false, $null = false) {
  $data = array(
    'pid' => $party->pid,
    'sid' => $set_id,
    'main' => $main,
    'hat' => $hat,
    'hat_main' => $hat_main,
    'null' => $null,
  );

  drupal_write_record('crm_party_data_set_'.$set_type, $data);
}

/**
 * Unattach a data set from a party
 *
 * @param $party the party object
 * @param $set_type The set type as defined in hook_data_set_info
 * @param $set_id The set id as stored in the related table
 *
 * @todo Implement
 */
function crm_party_data_set_instance_detach($party, $set_type, $set_id){
  return TRUE;
}

/**
 * Get party piece instances
 *
 * @param $parent
 *  Id of the parent party piece
 * @param $party_type
 *  The party type we're looking at
 * @param $party_piece
 *  (optional) the Piece we're looking for
 */
function crm_party_get_party_piece_instances($parent, $party_type, $party_pieces = null) {
  // Build the query;
  $query = db_select('crm_party_party_pieces','pp');
  $query->fields('pp');
  $query->condition('parent_id', $parent, '=');
  if (is_array($party_pieces)) {
    $query->condition('party_piece', $party_pieces, 'IN');
  }
  $query->condition('party_type', $party_type, '=');
  $query->orderBy('weight');

  // Get all the results that fit
  $results = $query->execute()->fetchAllAssoc('instance_id');
  foreach ($results as $key => $result) {
    // Decode the arguments into a useable form.
    $results[$key]['arguments'] = json_decode($result['arguments'], true);
  }
  return $results;
}

/**
 * Add a new party piece instance
 * 
 * @param $instance array of all values needed for this instance
 */
function crm_party_save_party_piece_instance($instance = array()) {
  //Do checks to make sure everthing is there
  
  //Encode arguments
  $instance['arguments'] = json_encode($instance['arguments']);
  
  //If the $instance['instance_id'] is set, we're updating.
  if(isset($instance['instance_id'])) {
    $id = $instance['instance_id'];
    unset($instance['instance_id']);
    drupal_write_record('crm_party_party_pieces',$instance,$id);
  }
  else {
    drupal_write_record('crm_party_party_pieces',$instance);
  }
}

/**
 * Delete a party piece instance
 *
 * @param $instance integer id of the instance to delete
 *
 * @return True on success, False on failure
 * @todo: implement
 */
function crm_party_delete_party_piece_instance($instance) {
  return true;
} 

/**
 * Display a party piece
 *
 * @param $party the party object we're looking at
 * @param $instance the instance of a party piece either an id or associative array
 *   (one row from crm_party_get_party_pieces);
 *
 * @todo workout something to do with permissions
 * @todo
 */
function crm_party_party_piece_display($party, $instance) {
  if (is_numeric($instance)) {
    // Build the query;
    $query = db_select('crm_party_party_pieces','pp');
    $query->fields('pp');
    $query->condition('instance_id', $instance, '=');
    // Get the row
    $result = $query->execute()->fetchAssoc();
    $result['arguments'] = json_decode($result['arguments'], true);
    $instance = $result;
  }

  //Call the display function
  $pieces = crm_party_party_piece_info();
  $function = $pieces[$instance['party_piece']]['display callback'];

  if (function_exists($function)) {
    $result = call_user_func($function, $party, $instance, $instance['title'], $instance['arguments']);
  }
  else {
    return false;
  }

  //If the Party Piece can have children, load those children
  if ($pieces[$instance['party_piece']]['nesting']) {
    $result += crm_party_party_piece_display_children($party, $instance);
  }

  return $result;
}

/**
 * display the children party pieces
 *
 * @param $party The party we're looking at.
 * @param $instance The instance of the parent.
 *
 * @return
 *    An array of renderable arrays keyed by "child_piece_<child_instance_id>"
 *
 * @todo Implement. Use crm_party_get_party_pieces. And crm_party_piece_display.
 */
function crm_party_party_piece_display_children($party, $instance) {
  return array();
}

/**
 * Display a tab
 *
 * @todo Implement. Use crm_party_party_piece_display_children() to get hte children of the tab.
 */
function crm_party_party_piece_tab_display($party, $instance, $title, $arguments) {
  return array();
}

/**
 * Implements hook_permission().
 */
function crm_party_permission() {
  return array(
    'administer crm settings' => array(
      'title' => t('Administer CRM settings'),
      'restrict access' => TRUE,
    ),
    'administer party types' => array(
      'title' => t('Administer party types'),
      'restrict access' => TRUE,
    ),
    'administer parties' =>  array(
      'title' => t('Administer parties'),
      'restrict access' => TRUE,
    ),
    'create parties' => array(
      'title' => t('Create parties'),
    ),
    'view parties' => array(
      'title' => t('View parties'),
    ),
    'edit parties' => array(
      'title' => t('Edit parties'),
    )
  );
}

/**
 * URI callback for contacts.
 */
function crm_party_uri($party) {
  return array('path' => 'party/' . $party->pid, );
}

/**
 * Implements hook_theme().
 */
function crm_party_theme() {
  return array(
    'crm_party_settings_pieces_order_form' => array(
      'render element' => 'form',
    ),
    'crm_party_email' => array(
      'variables' => array('crm_party_email', 'crm_party' => NULL),
      'template' => 'crm_party_email',
    ),
  );
}

/**
 * Load a single contact.
 */
function crm_party_load($pid = NULL, $reset = FALSE) {
  $pids = (isset ($pid) ? array($pid) : array());
  $party = crm_party_load_multiple($pids, $reset);
  return $party ? reset ($party) : FALSE;
}

/**
 * Load many contacts.
 */
function crm_party_load_multiple($pids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('crm_party', $pids, $conditions, $reset);
}

/**
 * Delete a party.
 */
function crm_party_delete(CRMParty $party) {
  $party->delete();
}

/**
 * Save a crm_party.
 *
 *  @param $info
 *
 */
function crm_party_save(&$party) {
  return entity_get_controller('crm_party')->save($party);
}

/**
 * Create a crm_party object ready for saving to the database.
 *
 * @param $info
 *  An array carrying all the important information.
 *
 * @return
 *  A party object that can be passed to crm_party_save().
 */
function crm_party_create($info) {
  if (!is_array($info)) {
    return FALSE;
  }
  if (!isset($info['type'])) {
    return FALSE;
  }

  return (object) $info;
}

/**
 * Implements hook_party_operations.
 */
function crm_party_party_operations() {
  $operations = array(
    'merge' => array(
      'label' => t('Merge parties'),
      'callback' => 'crm_party_party_operations_merge',
    ),
  );
  return $operations;
}

/**
 * Merge multiple users.
 */
function crm_party_party_operations_merge($parties) {
  // @todo: write me!
}

/**
 * Implements hook_views_api().
 */
function crm_party_views_api() {
  return array(
    'api' => '3.0-alpha1',
    'path' => drupal_get_path('module', 'crm_party') . '/includes',
  );
}

// -----------------------------------------------------------------------
// CTools hook implementations.

/**
 * Implements hook_ctools_plugin_type().
 *
 * Declare the plugin types we invent.
 */
function crm_party_ctools_plugin_type() {
  // Party name label plugins provide ways to generate a party name label
  // from a party.
  $plugins['party_name_label'] = array(
  );

  return $plugins;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function crm_party_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'crm_party') {
    return "plugins/$plugin_type";
  }
}

