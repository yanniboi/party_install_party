<?php

/**
 * @file
 * Support for configurable user profiles which are not attached to users.
 */
 
/**
 * Implements hook_entity_info_alter()
 *
 * Add a new view mode to profile2's for parties
 */
function crm_profile_entity_info_alter(&$entity_info) {
  $entity_info['profile2']['crm controller class'] = 'Profile2CRMController';
  // Pass this on to the controller class to make further changes.
  Profile2CRMController::hook_entity_info_alter($entity_info['profile2']);
}

/**
 * Implements hook_crm_party_data_set_info().
 */
function crm_profile_crm_party_data_set_info() {
  // Because this hook is invoked from hook_schema(), bad things happen if
  // we use profile2_get_types(). Hence just grab the type names directly
  // as that is all we need.
  // See http://drupal.org/node/1307506 for more details.
  $result = db_query("SELECT type, label FROM {profile_type}");
  $types = $result->fetchAllKeyed();

  $sets = array();
  foreach ($types as $type => $label) {
    $sets["profile2_" . $type] = array(
      'label' => $label,
      'entity type' => 'profile2',
      'entity bundle' => $type,
      //'load callback' => "crm_profile_load_profile", - No Longer needed with class implementation
      //'load arguments' => array($type),
      //'form callback' => "crm_profile_attached_entity_form",
      'class' => 'Profile2CRMController',
      // Provide details of admin interfaces
      'admin' => array(
        'create' => 'admin/structure/profiles/add',
        'import' => 'admin/structure/profiles/import',
        'edit' => 'admin/structure/profiles/manage/' . $type,
        'manage fields' => 'admin/structure/profiles/manage/' . $type . '/fields',
        'manage display' => 'admin/structure/profiles/manage/' . $type . '/display',
        'clone' => 'admin/structure/profiles/manage/' . $type . '/clone',
        'delete' => 'admin/structure/profiles/manage/' . $type . '/delete',
        'export' => 'admin/structure/profiles/manage/' . $type . '/export',
      ),
      // Provide a piece corresponding to each data set.
      'piece' => array(
        'path' => 'profile-' . str_replace('_', '-', $type),
        'title' => $label,
        'uses views' => TRUE,
        'page callback' => 'crm_party_view_data_set',
        'page arguments' => array(1, "profile2_" . $type),
        // @todo: this needs to tell the access arguments for crm_party_access()
        // about the argument for loading our attached entities.
        // In other words, some sort of %wildcard_to_arg() function maybe?
        'access arguments' => array("view any $type profile"),
        // File path is relative to implementing module.
        'file' => 'crm_party.pages.inc',
      ),
    );
  }
  return $sets;
}

/**
 * Implements hook_profile2_type_insert().
 */
function crm_profile_profile2_type_insert($type) {
}

/**
 * Implements hook_profile2_type_delete().
 */
function crm_profile_profile2_type_delete($type) {
}


/**
 * Load a profile
 *
function crm_profile_load_profile($party, $set_type, $set_id, $type) {
  return entity_load('profile2', $set_id);
}

/**
 * Return the stuff to go inside a party form
 * @todo: Make this have $form and $form_state
 * @todo: finish
 */
function crm_profile_attached_entity_form($form, &$form_state, &$attached_entity, $party) {
  $attached_entity_form = array();
  
  $profile = $attached_entity->entity;
  
  field_attach_form('profile2', $profile, $attached_entity_form, $form_state); 

  if (count(field_info_instances('profile2', $profile->type)) == 0) {
    $attached_entity_form['message'] = array(
      '#access' => user_access('administer profile types'), 
      '#markup' => t('No fields have been associated with this profile type. Go to the <a href="!url">Profile types</a> page to add some fields.', array('!url' => url('admin/structure/profiles'))),
    );
  }  
  
  return($attached_entity_form);
}

function crm_profile_attached_entity_form_submit($form, &$form_state, &$attached_entity, $party) {
  $hash = $attached_entity->hash();
  
  //save the profile
  profile2_save($attached_entity->entity);
  
  //submit fields
  field_attach_submit('profile2', $attached_entity->entity, $form[$hash], $form_state);
  profile2_save($attached_entity->entity);
}

function crm_profile_attached_entity_form_validate($form, &$form_state, &$attached_entity, $party) {
  //validate fields
  $pseudo_entity = (object) $form_state['values'][$attached_entity->hash()];
  $psuedo_entity->type = $attached_entity->getEntityBundle();
  field_attach_form_validate('profile2', $pseudo_entity, $form[$attached_entity->hash()], $form_state);
}

/**
 * Change the Party Details Page
 *
 * @todo: see crm_profile_crm_party_party_pieces() -- this function should
 * be broken up and made into the callback for that. Unless P2 provides us
 * with something we can use.
 * Also, next phase is a Views plugin that provides a party piece.
 *
 * @param $party
 *   A party object.
 *
 * @return 
 *   An array
 */
function crm_profile_crm_party_page_view_alter($party) {
  $build = array();
  // broken right now.
  return;
  
  $allProfiles = _crm_profile_load_by_party($party);
  
  foreach ($allProfiles as $type => $profiles) {
    //as $profiles could be a list of profiles we need to standardise what we're dealing with.
    if (is_object($profiles)) {
      $temp = $profiles;
      $profiles = array();
      $profiles[] = $temp;
    }
    foreach ($profiles as $profile) {
      if (profile2_access('view', $profile)) {
        $profile->this_party = $party;
        
        $build['profile_' . $profile->pid] = array(
          '#type' => 'fieldset',
          '#title' => $profile->label,
        );
        $build['profile_' . $profile->pid]['view'] = $profile->view('party');
      }
    }
    $build['profile_' . $type . '_add']['#markup'] = "<div class=\"clearfix\">
      <div class=\"crm_profile_ops\" style=\"float: right\">" . l("Add " . reset($profiles)->label, 'party/' . $party->pid . '/add/' . $type) . "
        </div>
      </div>";
  }
  
  return $build;
}

/**
 * Load all parties related to a given profile.
 *
 * @param $profile
 *   Either a profile2 object or the id of a profile.
 */
function _crm_profile_load_parties($profile) {
  $pid = is_object($profile) ? $profile->pid : $profile;
  $parties = array();
  
  $raw = _crm_profile_relation_get_related_entities('profile2', $pid, 'party_to_profile2_' . $profile->type);
  foreach ($raw as $relation) {
    foreach ($relation as $party) {
      $parties[$party->pid] = $party;
    }
  }
  
  return $parties;
}

/**
 * Controller class for CRM integration.
 *
 * @todo: move this to an inc file for autoloading.
 */
class Profile2CRMController extends EntityDefaultCRMController {
  const ENTITY_ID_KEY = "pid";
  
  // @todo Remove somehow.
  const VIEW_MODE = 'party';
  
  public function form(&$form, &$form_state) {
    // If we're adding a set
    if ($this->eid === NULL) {
      $this->entity = profile_create(array(
        'type'  => substr($this->type, 9), // @todo get rid of the profile2_ at the beginning
        // The uid needs to be set even if it is NULL.
        'uid'   => NULL,
      ));
    }

    // @todo: don't stash things in the form state; put them either
    // in the form as hash properties or values.
    $form_state['profiles'][$this->entity->type] = $this->entity;
    $form_state['entity'] = $this->entity;
    $form_state['party'] = $this->party;
    profile2_attach_form($form, $form_state);

    return $form;
  }
}
