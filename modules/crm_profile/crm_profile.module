<?php

/**
 * @file
 * Support for configurable user profiles which are not attached to users.
 */
 
/**
 * Implements hook_menu()
 *
 * Define a page to edit a profile in place.
 * DEPRECATED this will now be done with data sets
 */
function crm_profile_menu() {
  // @todo: not sure we should be fiddling with profile's menu stuff!
  $items['profile/%profile2/edit'] = array(
    'title' => 'Edit Profile',
    'page callback' => 'profile_page_edit',
    'page arguments' => array(1),
    'access callback' => 'profile2_access',
    'access arguments' => array('update', 1),
    'file' => 'crm_profile.pages.inc',
  );
  $items['party/%crm_party/add/%profile2_type'] = array(
    'title' => 'Add Profile',
    'page callback' => 'profile_page_add',
    'page arguments' => array(1,3),
    'access callback' => 'profile2_access',
    'access arguments' => array('create',3),
    'file' => 'crm_profile.pages.inc',
  );
  return $items;
}

/**
 * Implements hook_crm_party_data_set_info().
 */
function crm_profile_crm_party_data_set_info() {
  // Because this hook is invoked from hook_schema(), bad things happen if
  // we use profile2_get_types(). Hence just grab the type names directly
  // as that is all we need.
  // See http://drupal.org/node/1307506 for more details.
  $result = db_query("SELECT type, label FROM {profile_type}");
  $types = $result->fetchAllKeyed();

  $sets = array();
  foreach ($types as $type => $label) {
    $sets["profile2_" . $type] = array(
      'label' => $label,
      'entity type' => 'profile2',
      //'load callback' => "crm_profile_load_profile", - No Longer needed with class implementation
      //'load arguments' => array($type),
      //'form callback' => "crm_profile_form", - No longer needed with class implementation
      //'form arguments' => array($type),
      'class' => 'Profile2DataSet',
      // Provide a piece corresponding to each data set.
      'piece' => array(
        'path' => 'profile-' . str_replace('_', '-', $type),
        'title' => $label,
        'page callback' => 'crm_user_party_view_user', // @todo: change this!
        'page arguments' => array(1),
        'access arguments' => array("view any $type profile"), // @todo: IMCTT.
      ),
    );
  }
  return $sets;
}

/**
 * Implements hook_profile2_type_insert().
 *
 * Add a data set relation table when a new profile2 type is created.
 */
function crm_profile_profile2_type_insert($type) {
  crm_party_data_set_type_add("profile2_" . $type->type);
}

/**
 * Implements hook_profile2_type_delete().
 */
function crm_profile_profile2_type_delete($type) {
  crm_party_data_set_type_remove("profile2_" . $type->type);
}


/**
 * Load a profile
 */
function crm_profile_load_profile($party, $set_type, $set_id, $type) {
  return entity_load('profile2', $set_id);
}

/**
 * Get the profile2 form data
 * @todo: Make this have $form and $form_state
 * @todo: finish
 */
function crm_profile_form(&$form, &$form_state, $party, $set_type, $set_id, $type) {
  // Make sure the uid is null. 
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => null,
  );
  
  if(is_numeric($set_id)) {
    $form_state['profiles'][$type] = entity_load('profile2', $set_id);
  }
  else {
    $form_state['profiles'][$type] = profile_create(array('type' => $type));
  }  
  profile2_attach_form($form, $form_state);  
}

/**
 * Implements hook_entity_info_alter()
 *
 * Add a new view mode to profile2's for parties
 */
function crm_profile_entity_info_alter(&$entity_info) {
  $entity_info['profile2']['view modes']['party'] = array(
    'label' => t('Party Display'),
    'custom settings' => false,
  );
}

/**
 * Implements hook_preprocess_HOOK()
 * 
 * Lets add a new tpl for party display
 */
function crm_profile_preprocess_entity(&$vars) {
  //Add a new profile view tpl.
  if ($vars['view_mode'] == 'party') {
    $vars['theme_hook_suggestions'][] = 'profile2__all__party';
  }
}

/**
 * Implements hook_form_FORM_ID_alter()
 *
 * Alter Party forms to do things
 */
function crm_profile_form_crm_party_edit_form_alter(&$form, &$form_state, $form_id) {
  // Make sure the uid is null. 
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => null,
  );  
  
  $profiles = array();
  if (isset($form['pid'])) {
    $profiles = _crm_profile_load_by_party($form['pid']['#value']);
  }  
  
  // Load appropriate profile2s and attach them to the party form
  foreach (profile2_get_types() as $type_name => $profile_type) {
    if (isset($profiles[$type_name])) {
      $form_state['profiles'][$type_name] = $profiles[$type_name];
    }
    
    if (empty($form_state['profiles'][$type_name])) {
      $form_state['profiles'][$type_name] = profile_create(array('type' => $type_name));
    }
    profile2_attach_form($form, $form_state);
    // Wrap each profile form in a fieldset.
    $form['profile_' . $type_name] += array(
      '#type' => 'fieldset',
      '#title' => check_plain($profile_type->label),
    );
  }
  
  $form['#submit'][] = 'crm_profile_post_form_submit_relate';
}

/**
 * Relate the profile2 entities to the crm_party in form_state
 */
function crm_profile_post_form_submit_relate($form, &$form_state) {
  $party = $form_state['crm_party'];
  $profiles = array();
  
  foreach (profile2_get_types() as $type_name => $profile_type) {
    if (isset($form_state['profiles'][$type_name])) {
      $profiles[] = $form_state['profiles'][$type_name];
    } 
    else {
      $thisProfile = profile_create(array('type' => $type_name, 'uid' => null));
      profile2_save($thisProfile);
      $profiles[] =  $thisProfile;
    } 
  }
  
  // Foreach profile2 in the form state add a binary relation linking it
  // to the party
  foreach ($profiles as $profile) {
    _crm_party_profile_relate($party, $profile);
  }
}

/**
 * Relate a party entity to a profile2 entity
 *
 * @param $party
 *   A fully loaded party object, from crm_party_load(). Whats important is that the pid is correct.
 * @param $profile
 *   A profile2 object
 */
function _crm_party_profile_relate($party, $profile) {
  $endpoints = array();
  $endpoints[] = array(
    'entity_type' => 'crm_party',
    'entity_id' => $party->pid,
  );
  $endpoints[] = array(
    'entity_type' => 'profile2',
    'entity_id' => $profile->pid,
  );
  
  //create a relation for each party profile2 which is created.
  $relation = relation_create('party_to_profile2_'.$profile->type, $endpoints);
  $rid = relation_save($relation);

  //set some nice messages - change
  drupal_set_message('Party: ' . $party->label . ' has been related to Profile: ' . $profile->pid);
}

/**
 * Change the Party Details Page
 *
 * @todo: see crm_profile_crm_party_party_pieces() -- this function should
 * be broken up and made into the callback for that. Unless P2 provides us
 * with something we can use.
 * Also, next phase is a Views plugin that provides a party piece.
 *
 * @param $party
 *   A party object.
 *
 * @return 
 *   An array
 */
function crm_profile_crm_party_page_view_alter($party) {
  $build = array();
  $allProfiles = _crm_profile_load_by_party($party);
  foreach ($allProfiles as $type => $profiles) {
    //as $profiles could be a list of profiles we need to standardise what we're dealing with.
    if (is_object($profiles)) {
      $temp = $profiles;
      $profiles = array();
      $profiles[] = $temp;
    }
    foreach ($profiles as $profile) {
      _crm_profile_is_null($profile);
      if (!$profile->is_null && profile2_access('view', $profile)) {
        $profile->this_party = $party;
        
        $build['profile_' . $profile->pid] = array(
          '#type' => 'fieldset',
          '#title' => $profile->label,
        );
        $build['profile_' . $profile->pid]['view'] = $profile->view('party');
      }
    }
    $build['profile_' . $type . '_add']['#markup'] = "<div class=\"clearfix\">
      <div class=\"crm_profile_ops\" style=\"float: right\">".l("Add " . reset($profiles)->label, 'party/' . $party->pid . '/add/' . $type)."
        </div>
      </div>";
  }
  
  return $build;
}

/**
 * Implements hook_entity_insert().
 *
 * Make the right relation when a profile type is added.
 */
// OBSOLETE -- we are using hook_profile2_type_insert() above.
/* 
function crm_profile_entity_insert($entity, $type) {
  if ($type == 'profile2_type') {  
    // Create the null profile.
    $profile = profile_create(array('type' => $entity->type, 'uid' => NULL));
    profile2_save($profile);
      
    $data = array(
      'type' => $entity->type,
      'pid' => $profile->pid,
    );
    drupal_write_record('crm_profile_null', $data);

    //Create a relation type
    $relation_type = array(
      'relation_type' => 'party_to_profile2_' . $entity->type,
      'label' => 'Party to Profile ' . $entity->label,
      'max_arity' => 2,
      'source_bundles' => array(
        'crm_party:*',
        'profile2:' . $entity->type,
      ),
    );
    
    relation_type_save($relation_type); 
    drupal_set_message(t("Contact to profile @entity-label created", array(
      '@entity-label' => $entity->label,
    )));
    
    //TODO: Relate every existing party to this null profile;
    $query = db_select('crm_party', 'cp');
    $query->fields('cp');
    $result = $query->execute();
    
    while ($record = $result->fetchAssoc()) {
      //this is cheating so we can use another function, probably the function needs to be fixed
      $party = new stdClass();
      $party->pid = $record['pid'];
      $party->label = $record['label'];
      
      _crm_party_profile_relate($party, $profile);
    }
  }
}
*/


/**
 * Load all the profiles for a given party. 
 *
 * @param $party
 *   Either a party object or the id of a party.
 *
 * @return 
 *  An array of profiles attached to this party of the for ['type'][] = $profile;
 */
function _crm_profile_load_by_party($party) {
  // Get the pid from whatever is passed.
  $pid = is_object($party) ? $party->pid : $party;
  $profiles = array();
  
  foreach (profile2_get_types() as $type_name => $profile_type) {
    $raw = _crm_profile_relation_get_related_entities('crm_party', $pid, 'party_to_profile2_' . $type_name);
    foreach ($raw as $relation) {
      foreach ($relation as $profile) {
        $profiles[$type_name][] = $profile;
      }
    }

    if (isset($profiles[$type_name]) && count($profiles[$type_name]) == 1) {
      $profiles[$type_name] = reset($profiles[$type_name]);
    }
  } 
  return $profiles;
}

/**
 * Load all parties related to a given profile.
 *
 * @param $profile
 *   Either a profile2 object or the id of a profile.
 */
function _crm_profile_load_parties($profile) {
  $pid = is_object($profile) ? $profile->pid : $profile;
  $parties = array();
  
  $raw = _crm_profile_relation_get_related_entities('profile2', $pid, 'party_to_profile2_' . $profile->type);
  foreach ($raw as $relation) {
    foreach ($relation as $party) {
      $parties[$party->pid] = $party;
    }
  }
  
  return($parties);
}

/**
 * Find out if a profile is a null profile.
 */
function _crm_profile_is_null(&$profile) {
  $query = db_select('crm_profile_null');
  $query->condition('pid', $profile->pid, '=');
  $query = $query->countQuery();
  $result = $query->execute();
  $record = $result->fetchAssoc();
  
  if ($record['expression'] == '1') {
    $profile->is_null = TRUE;
  }
  else {
    $profile->is_null = FALSE;
  }
}

/**
 * Helper function to get all related entities via relation API.
 *
 * This is just a stand-in until http://drupal.org/node/1288894 gets in, and
 * make developing CRM require one less patch to contrib modules.
 */
function _crm_profile_relation_get_related_entities($entity_type, $entity_id, $relation_type = NULL, $r_index = NULL) {
  $query = relation_query($entity_type, $entity_id, $r_index);
  if ($relation_type) {
    $query->propertyCondition('relation_type', $relation_type);
  }
  $results = $query->execute();
  $relations = array();
  foreach($results as $result) {
    if (empty($result)) {
      return FALSE;
    }
    $relation = relation_load($result->rid);
    $request_key = $entity_type . ':' . $entity_id;
    $entities = $relation->endpoints[LANGUAGE_NONE];
    $first_entity_key = $entities[0]['entity_type'] . ':' . $entities[0]['entity_id'];
    if (isset($r_index)) {
      $request_key = $request_key . ':' . $r_index;
      $first_entity_key = $first_entity_key . ':' . $entities[0]['r_index'];
    }
    if ($request_key == $first_entity_key) {
      $other_endpoints = entity_load($entities[1]['entity_type'], array($entities[1]['entity_id']));
      $relations[$result->rid] = $other_endpoints;
    }
    else {
      $other_endpoints = entity_load($entities[0]['entity_type'], array($entities[0]['entity_id']));
      $relations[$result->rid] = $other_endpoints;
    }
  }
  return $relations;
}

/**
 * Profile2DataSet
 */
class Profile2DataSet extends CRMPartyDataSet 
{
  const ENTITY_TYPE = "profile2";
  const ENTITY_ID_KEY = "pid";
}
