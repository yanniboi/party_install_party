<?php

/**
 * @file
 * Support for configurable user profiles which are not attached to users.
 */
 
/**
 * Implements hook_menu()
 *
 * Define a page to edit a profile in place.
 * DEPRECATED this will now be done with data sets
 */
function crm_profile_menu() {
  /* @todo: not sure we should be fiddling with profile's menu stuff!
  $items['profile/%profile2/edit'] = array(
    'title' => 'Edit Profile',
    'page callback' => 'profile_page_edit',
    'page arguments' => array(1),
    'access callback' => 'profile2_access',
    'access arguments' => array('update', 1),
    'file' => 'crm_profile.pages.inc',
  );
  /*$items['party/%crm_party/add/%profile2_type'] = array(
    'title' => 'Add Profile',
    'page callback' => 'profile_page_add',
    'page arguments' => array(1,3),
    'access callback' => 'profile2_access',
    'access arguments' => array('create',3),
    'file' => 'crm_profile.pages.inc',
  );
  return $items;*/
}

/**
 * Implements hook_entity_info_alter()
 *
 * Add a new view mode to profile2's for parties
 */
function crm_profile_entity_info_alter(&$entity_info) {
  $entity_info['profile2']['crm controller class'] = 'Profile2CRMController';
  // Pass this on to the controller class to make further changes.
  Profile2CRMController::hook_entity_info_alter($entity_info['profile2']);
}

/**
 * Implements hook_crm_party_data_set_info().
 */
function crm_profile_crm_party_data_set_info() {
  // Because this hook is invoked from hook_schema(), bad things happen if
  // we use profile2_get_types(). Hence just grab the type names directly
  // as that is all we need.
  // See http://drupal.org/node/1307506 for more details.
  $result = db_query("SELECT type, label FROM {profile_type}");
  $types = $result->fetchAllKeyed();

  $sets = array();
  foreach ($types as $type => $label) {
    $sets["profile2_" . $type] = array(
      'label' => $label,
      'entity type' => 'profile2',
      'entity bundle' => $type,
      //'load callback' => "crm_profile_load_profile", - No Longer needed with class implementation
      //'load arguments' => array($type),
      'form callback' => "crm_profile_attached_entity_form",
      'class' => 'Profile2CRMController',
      // Provide details of admin interfaces
      'admin' => array(
        'create' => 'admin/structure/profiles/add',
        'import' => 'admin/structure/profiles/import',
        'edit' => 'admin/structure/profiles/manage/' . $type,
        'manage fields' => 'admin/structure/profiles/manage/' . $type . '/fields',
        'manage display' => 'admin/structure/profiles/manage/' . $type . '/display',
        'clone' => 'admin/structure/profiles/manage/' . $type . '/clone',
        'delete' => 'admin/structure/profiles/manage/' . $type . '/delete',
        'export' => 'admin/structure/profiles/manage/' . $type . '/export',
      ),
      // Provide a piece corresponding to each data set.
      'piece' => array(
        'path' => 'profile-' . str_replace('_', '-', $type),
        'title' => $label,
        'uses views' => TRUE,
        'page callback' => 'crm_party_view_data_set',
        'page arguments' => array(1, "profile2_" . $type),
        // @todo: this needs to tell the access arguments for crm_party_access()
        // about the argument for loading our attached entities.
        // In other words, some sort of %wildcard_to_arg() function maybe?
        'access arguments' => array("view any $type profile"),
        // File path is relative to implementing module.
        'file' => 'crm_party.pages.inc',
      ),
    );
  }
  return $sets;
}

/**
 * Implements hook_profile2_type_insert().
 */
function crm_profile_profile2_type_insert($type) {
}

/**
 * Implements hook_profile2_type_delete().
 */
function crm_profile_profile2_type_delete($type) {
}


/**
 * Load a profile
 *
function crm_profile_load_profile($party, $set_type, $set_id, $type) {
  return entity_load('profile2', $set_id);
}

/**
 * Return the stuff to go inside a party form
 * @todo: Make this have $form and $form_state
 * @todo: finish
 */
function crm_profile_attached_entity_form($form, &$form_state, &$attached_entity, $party) {
  $attached_entity_form = array();
  
  $profile = $attached_entity->entity;
  
  field_attach_form('profile2', $profile, $attached_entity_form, $form_state); 

  if (count(field_info_instances('profile2', $profile->type)) == 0) {
    $attached_entity_form['message'] = array(
      '#access' => user_access('administer profile types'), 
      '#markup' => t('No fields have been associated with this profile type. Go to the <a href="!url">Profile types</a> page to add some fields.', array('!url' => url('admin/structure/profiles'))),
    );
  }  
  
  return($attached_entity_form);
}

function crm_profile_attached_entity_form_submit($form, &$form_state, &$attached_entity, $party) {
  $hash = $attached_entity->hash();
  
  //save the profile
  profile2_save($attached_entity->entity);
  
  //submit fields
  field_attach_submit('profile2', $attached_entity->entity, $form[$hash], $form_state);
  dsm($attached_entity);
}

function crm_profile_attached_entity_form_validate($form, &$form_state, &$attached_entity, $party) {
  //validate fields
  $pseudo_entity = (object) $form_state['values'][$attached_entity->hash()];
  $psuedo_entity->type = $attached_entity->getEntityBundle();
  field_attach_form_validate('profile2', $pseudo_entity, $form[$attached_entity->hash()], $form_state);
}

/**
 * Implements hook_form_FORM_ID_alter()
 *
 * Alter Party forms to do things
 */
function crm_profile_form_crm_party_edit_form_alter(&$form, &$form_state, $form_id) {
  return; 
  // Make sure the uid is null. 
  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => NULL,
  );  
  
  $profiles = array();
  if (isset($form['pid'])) {
    $profiles = _crm_profile_load_by_party($form['pid']['#value']);
  }  
  
  // Load appropriate profile2s and attach them to the party form
  foreach (profile2_get_types() as $type_name => $profile_type) {
    if (isset($profiles[$type_name])) {
      $form_state['profiles'][$type_name] = $profiles[$type_name];
    }
    
    if (empty($form_state['profiles'][$type_name])) {
      $form_state['profiles'][$type_name] = profile_create(array('type' => $type_name));
    }
    profile2_attach_form($form, $form_state);
    // Wrap each profile form in a fieldset.
    $form['profile_' . $type_name] += array(
      '#type' => 'fieldset',
      '#title' => check_plain($profile_type->label),
    );
  }
  
  $form['#submit'][] = 'crm_profile_post_form_submit_relate';
}

/**
 * Relate the profile2 entities to the crm_party in form_state
 *
function crm_profile_post_form_submit_relate($form, &$form_state) {
  $party = $form_state['crm_party'];
  $profiles = array();
  
  foreach (profile2_get_types() as $type_name => $profile_type) {
    if (isset($form_state['profiles'][$type_name])) {
      $profiles[] = $form_state['profiles'][$type_name];
    } 
    else {
      $thisProfile = profile_create(array('type' => $type_name, 'uid' => null));
      profile2_save($thisProfile);
      $profiles[] =  $thisProfile;
    } 
  }
  
  // Foreach profile2 in the form state add a binary relation linking it
  // to the party
  foreach ($profiles as $profile) {
    crm_party_relate($party, $profile, 'profile2_' . $profile->type);
  }
}

/**
 * Relate a party entity to a profile2 entity
 *
 * @param $party
 *   A fully loaded party object, from crm_party_load(). Whats important is that the pid is correct.
 * @param $profile
 *   A profile2 object
 *
function _crm_party_profile_relate($party, $profile) {
  $endpoints = array();
  $endpoints[] = array(
    'entity_type' => 'crm_party',
    'entity_id' => $party->pid,
  );
  $endpoints[] = array(
    'entity_type' => 'profile2',
    'entity_id' => $profile->pid,
  );
  
  //create a relation for each party profile2 which is created.
  $relation = relation_create('party_to_profile2_'.$profile->type, $endpoints);
  $rid = relation_save($relation);

  //set some nice messages - change
  drupal_set_message('Party: ' . $party->label . ' has been related to Profile: ' . $profile->pid);
}

/**
 * Change the Party Details Page
 *
 * @todo: see crm_profile_crm_party_party_pieces() -- this function should
 * be broken up and made into the callback for that. Unless P2 provides us
 * with something we can use.
 * Also, next phase is a Views plugin that provides a party piece.
 *
 * @param $party
 *   A party object.
 *
 * @return 
 *   An array
 */
function crm_profile_crm_party_page_view_alter($party) {
  $build = array();
  // broken right now.
  return;
  
  $allProfiles = _crm_profile_load_by_party($party);
  
  foreach ($allProfiles as $type => $profiles) {
    //as $profiles could be a list of profiles we need to standardise what we're dealing with.
    if (is_object($profiles)) {
      $temp = $profiles;
      $profiles = array();
      $profiles[] = $temp;
    }
    foreach ($profiles as $profile) {
      if (profile2_access('view', $profile)) {
        $profile->this_party = $party;
        
        $build['profile_' . $profile->pid] = array(
          '#type' => 'fieldset',
          '#title' => $profile->label,
        );
        $build['profile_' . $profile->pid]['view'] = $profile->view('party');
      }
    }
    $build['profile_' . $type . '_add']['#markup'] = "<div class=\"clearfix\">
      <div class=\"crm_profile_ops\" style=\"float: right\">" . l("Add " . reset($profiles)->label, 'party/' . $party->pid . '/add/' . $type) . "
        </div>
      </div>";
  }
  
  return $build;
}

/**
 * Load all the profiles for a given party. 
 *
 * @param $party
 *   Either a party object or the id of a party.
 *
 * @return 
 *  An array of profiles attached to this party of the for ['type'][] = $profile;
 *
function _crm_profile_load_by_party($party) {
  // Get the pid from whatever is passed.
  $pid = is_object($party) ? $party->pid : $party;
  $profiles = array();
  
  foreach (profile2_get_types() as $type_name => $profile_type) {
    $raw = _crm_profile_relation_get_related_entities('crm_party', $pid, 'party_to_profile2_' . $type_name);
    foreach ($raw as $relation) {
      foreach ($relation as $profile) {
        $profiles[$type_name][] = $profile;
      }
    }

    if (isset($profiles[$type_name]) && count($profiles[$type_name]) == 1) {
      $profiles[$type_name] = reset($profiles[$type_name]);
    }
  } 
  return $profiles;
}

/**
 * Load all parties related to a given profile.
 *
 * @param $profile
 *   Either a profile2 object or the id of a profile.
 */
function _crm_profile_load_parties($profile) {
  $pid = is_object($profile) ? $profile->pid : $profile;
  $parties = array();
  
  $raw = _crm_profile_relation_get_related_entities('profile2', $pid, 'party_to_profile2_' . $profile->type);
  foreach ($raw as $relation) {
    foreach ($relation as $party) {
      $parties[$party->pid] = $party;
    }
  }
  
  return $parties;
}

/**
 * Helper function to get all related entities via relation API.
 *
 * This is just a stand-in until http://drupal.org/node/1288894 gets in, and
 * make developing CRM require one less patch to contrib modules.
 *
function _crm_profile_relation_get_related_entities($entity_type, $entity_id, $relation_type = NULL, $r_index = NULL) {
  $query = relation_query($entity_type, $entity_id, $r_index);
  if ($relation_type) {
    $query->propertyCondition('relation_type', $relation_type);
  }
  $results = $query->execute();
  $relations = array();
  foreach($results as $result) {
    if (empty($result)) {
      return FALSE;
    }
    $relation = relation_load($result->rid);
    $request_key = $entity_type . ':' . $entity_id;
    $entities = $relation->endpoints[LANGUAGE_NONE];
    $first_entity_key = $entities[0]['entity_type'] . ':' . $entities[0]['entity_id'];
    if (isset($r_index)) {
      $request_key = $request_key . ':' . $r_index;
      $first_entity_key = $first_entity_key . ':' . $entities[0]['r_index'];
    }
    if ($request_key == $first_entity_key) {
      $other_endpoints = entity_load($entities[1]['entity_type'], array($entities[1]['entity_id']));
      $relations[$result->rid] = $other_endpoints;
    }
    else {
      $other_endpoints = entity_load($entities[0]['entity_type'], array($entities[0]['entity_id']));
      $relations[$result->rid] = $other_endpoints;
    }
  }
  return $relations;
}
*/

/**
 * Controller class for CRM integration.
 *
 * @todo: move this to an inc file for autoloading.
 */
class Profile2CRMController extends EntityDefaultCRMController {
  const ENTITY_TYPE = "profile2";
  const ENTITY_ID_KEY = "pid";
  
  // @todo Remove somehow.
  const VIEW_MODE = 'party';
  
  public function form(&$form, &$form_state) {
    // If we're adding a set
    if ($this->eid === NULL) {
      $this->entity = profile_create(array(
        'type'  => substr($this->type, 9), // @todo get rid of the profile2_ at the beginning
        // The uid needs to be set even if it is NULL.
        'uid'   => NULL,
      ));
    }

    // @todo: don't stash things in the form state; put them either
    // in the form as hash properties or values.
    $form_state['profiles'][$this->entity->type] = $this->entity;
    $form_state['entity'] = $this->entity;
    $form_state['party'] = $this->party;
    profile2_attach_form($form, $form_state);

    return $form;
  }

  /**
   * Get the path argument for this set.
   */
   public function getPathArg() {
     // @todo: figure a way to move this back up. It's messy here.
     return str_replace('_', '-', 'profile-' . $this->entity->type);
   }
}
