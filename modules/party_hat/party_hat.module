<?php
/**
 * @file party_hat.module
 * Provides an extensible access system for CRM parties.
 */

/**
 * Implements hook_entity_info().
 */
function party_hat_entity_info() {
  // The hat entity.
  $entity_info['party_hat'] = array(
    'label' => t('Hat'),
    'entity class' => 'PartyHat',
    'controller class' => 'PartyHatController',
    // We define this so entity module provides us with basic Views data, while
    // allowing us to define more of our own.
    // See http://drupal.org/node/1307760.
    'views controller class' => 'EntityDefaultViewsController',
    'base table' => 'party_hat',
    'fieldable' => TRUE,
    'module' => 'party_hat',
    'entity keys' => array(
      'id' => 'hid',
      'label' => 'label',
      'name' => 'name',
    ),
    'exportable' => TRUE,
    'access callback' => 'party_hat_access',
    'uri callback' => 'party_hat_uri',
    'admin ui' => array(
      'controller class' => 'PartyHatUIController',
      'path' => 'admin/community/hats',
      'file' => 'party_hat.admin.inc',
    ),
    'bundles' => array(
      'hat' => array(
        'label' => t('Hat'),
        'admin' => array(
          'path' => 'admin/community/hats',
          'access arguments' => array('administer hats'),
        ),
      ),
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full Hat'),
        'custom settings' =>  FALSE,
      ),
    )
  );
  return $entity_info;
}

/**
 * Entity access callback.
 *
 * @param $op
 *   The operation being performed.
 * @param $party
 *   A party to check access for.
 * @param $account
 *   (optional) The user to check access for. Omit to check for the global user.
 *
 * @return
 *   Boolean; TRUE to grant access, FALSE to deny it.
 *
 * @see party_access
 */
function party_hat_access($op, $party = NULL, $account = NULL) {
  return user_access('administer hats');
}

/**
 * URI callback for hats.
 */
function party_hat_uri($party_hat) {
  // Uses the machine name, since these are exportables.
  return array('path' => 'admin/community/hats/manage/' . $party_hat->name);
}

/**
 * Implements hook_permission().
 */
function party_hat_permission() {
  return array(
    'administer hats' => array(
      'title' => t('Administer CRM party hats'),
      'description' => t('TODO write me.'),
    ),
  );
}

// -----------------------------------------------------------------------
// Party Hats API

/**
 * Save a hat.
 *
 * @param $hat a party_hat object.
 */
function party_hat_save(&$hat) {
  return entity_get_controller('party_hat')->save($hat);
}

/**
 * Load a hat.
 *
 * @param $hat_name
 *   The machine name of the hat to load.
 */
function party_hat_load($hat_name) {
  $query = db_select('party_hat', 'ph');
  $query->addField('ph', 'hid');
  $result = $query->condition('name', $hat_name, '=')
    ->execute()
    ->fetchAllAssoc('hid');

  $ids = array_keys($result);

  // @todo WTF? If $hat_name can be a numeric id it needs to be documented.
  if (count($ids) < 1 && is_numeric($hat_name)) {
    $ids = array($hat_name);
  }
  return reset(party_hat_load_multiple($ids));
}

/**
 * Load many hats.
 */
function party_hat_load_multiple($hids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('party_hat', $hids, $conditions, $reset);
}

/**
 * Save a hat data set rule.
 *
 * @param $hat
 *  The hat name
 * @param $set
 *  The set type
 *  @todo: does this mean the data set name? if so, rename.
 * @param $value
 *  The value
 *
 * @todo Refactor so that we don't do 3 queries to update one rule.
 *       At the moment we do 3 queries when we add a rule and 1 when we update it and 2 when we keep it the same..
 *       Is this better than 2 queries for both?
 */
function party_hat_set_data_set_rule($hat, $set, $values = array()) {
  //try updating the table
  $num_affected = db_update('party_hat_data_set_rules')
    ->fields($values)
    ->condition('hat', $hat, '=')
    ->condition('data_set', $set, '=')
    ->execute();

  if ($num_affected < 1) {
    // We have to check that we haven't kept the row the same.
    // @todo: refactor this so that we don't do 3 queries
    $count = db_select('party_hat_data_set_rules', 'c')
      ->fields('c')
      ->condition('hat', $hat, '=')
      ->condition('data_set', $set, '=')
      ->execute()
      ->rowCount();

    if ($count < 1) {
      $data = array(
        'hat' => $hat,
        'data_set' => $set,
      ) + $values;
      drupal_write_record('party_hat_data_set_rules',  $data);
    }
  }
}

/**
 * Get a hat data set rule.
 *
 * @param $hat
 *  The hat name
 * @param $set
 *  The set type
 *  @todo: does this mean the data set name? if so, rename.
 *
 * @return
 *  @todo write me.
 */
function party_hat_get_data_set_rule($hat, $set) {
  //select from the table where the hat and data set are right
  $results = db_select('party_hat_data_set_rules', 'c')
    ->fields('c')
    ->condition('hat', $hat, '=')
    ->condition('data_set', $set, '=')
    ->execute()
    ->fetchAllAssoc('phdsid');

  //if the rule doesn't exist yet return a default.
  if (count($results) < 1) {
    return array(
      'has' => 0,
      'multiple' => 0,
    );
  }

  //get the first $result (there should only ever be one)
  $result = reset($results);
  return array(
    'has' => $result->has,
    'multiple' => $result->multiple,
  );
}

/**
 * Implements hook_party_access().
 */
function party_hat_party_access($op, $party = NULL, $data_set = NULL, $account = NULL) {
  // We say nothing about access to just the party.
  if (!isset($data_set)) {
    return NULL;
  }

  switch ($op) {
    // View and attach ops are the same: you can't view a party's data set if
    // if can't have it attached either.
    case 'attach':
    case 'view':
      $data_set_name = $data_set['set_name'];

      $party_hats = party_hat_get_hats($party);
      $data_sets = array();
      foreach ($party_hats as $hat) {
        // Ugh these are values; would be better as keys.
        $hat_sets = party_hat_get_hat_data_sets($hat);
        // If any hat has the data set, grant access.
        if (in_array($data_set_name, $hat_sets)) {
          return TRUE;
        }
      }
      return FALSE;
  }
}

/**
 * Get all the sets for a Hat.
 *
 * This returns an array of sets that a Party Must have or can have multiple of.
 *
 * @todo write params and return.
 */
function party_hat_get_hat_data_sets($hat, $rule = 'has') {
  $results = db_select('party_hat_data_set_rules', 'c')
    ->fields('c')
    ->condition('hat', $hat->name, '=')
    ->condition($rule, 1, '=')
    ->execute()
    ->fetchAllAssoc('data_set');

  return array_keys($results);
}

/**
 * Get all the Hats a Party is Wearing
 *
 * @param $party
 *  The Party object or ID
 */
function party_hat_get_hats($party) {
  if (!is_object($party)) {
    $party = party_load($party);
  }

  $hats = array();
  // If this is an unsaved party (one without an ID)...
  if (!isset($party->pid)) {
    //Get all the "required"/"default" hats for this party type.
    $options = array(
      'required' => TRUE,
      'party_type' => $party->type,
    );
    return party_hat_get_all_hats($options);
  }
  else {
    $items = field_get_items('party', $party, 'party_hat');
    if ($items) {
      foreach ($items as $item) {
        $hat = party_hat_load($item['hat_name']);
        $hats[$hat->name] = $hat;
      }
    }
  }

  return $hats;
}

/**
 * Get all available hats.
 *
 * @todo: Make filter by party type.
 */
function party_hat_get_all_hats($options = array()) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'party_hat', '=');
  if (isset($options['required']) && $options['required']) {
    // filter the search by whether they're required
    $query->propertyCondition('required', 1, '=');
  }
  $result = $query->execute();
  $hids = array();

  if (!isset($result['party_hat']) || !is_array($result['party_hat'])) {
    return array();
  }

  foreach ($result['party_hat'] as $record) {
    $hids[] = $record->hid;
  }

  // Get the array keayed by hat name.
  $tempHats = entity_load('party_hat', $hids);
  $hats = array();
  foreach ($tempHats as $hat) {
    $hats[$hat->name] = $hat;
  }
  unset($tempHats);

  if (!isset($options['party_type'])) {
    return $hats;
  }

  foreach ($hats as $id => $hat) {
    if (!in_array($options['party_type'], $hat->data['party_types'])) {
      unset($hats[$id]);
    }
  }
  return $hats;
}

/**
 * Assign a number of hats to a party
 *
 * @param $party
 * @param $hats
 *   An array of hats to assign.
 */
function party_hat_assign_hats($party, $hats) {
  // Get the hat items from the party object
  $hat_items = field_get_items('party', $party, 'party_hat');

  foreach ($hats as $hat) {
    $has_hat = FALSE;
    foreach ($hat_items as $item) {
      if ($item['hat_name'] == $hat->name) {
        $has_hat = TRUE;
      }
    }

    // Don't add the hat if the Party already has it
    if ($has_hat) {
      continue;
    }

    $assigned_hats[] = $hat->name;
    $hat_items[]['hat_name'] = $hat->name;
  }

  $party->party_hat[LANGUAGE_NONE] = $hat_items;
  party_save($party);

  if (module_exists('rules')) {
    rules_invoke_all('party_hat_assign_hats', $party, $assigned_hats);
  }
  else {
    module_invoke_all('party_hat_assign_hats', $party, $assigned_hats);
  }
}

/**
 * Unassign hats
 *
 * @param $party
 * @param $hats
 *   An array of hats to unassign.
 */
function party_hats_unassign_hats($party, $hats) {
  // Get the hat items from the party object
  $hat_items = field_get_items('party', $party, 'party_hat');

  foreach ($hats as $hat) {
    $has_hat = FALSE;
    foreach ($hat_items as $delta => $item) {
      if ($item['hat_name'] == $hat->name) {
        $has_hat = TRUE;
        unset($hat_items[$delta]);
      }
    }

    // Don't remove the hat if its not assigned
    if (!$has_hat) {
      continue;
    }
    $unassigned_hats[] = $hat->name;
  }

  $party->party_hat[LANGUAGE_NONE] = $hat_items;
  party_save($party);

  if (module_exists('rules')) {
    rules_invoke_all('party_hat_unassign_hats', $party, $unassigned_hats);
  }
  else {
    module_invoke_all('party_hat_unassign_hats', $party, $unassigned_hats);
  }
}

/**
 * Implements hook_theme().
 */
function party_hat_theme($existing, $type, $theme, $path) {
  return array(
    'crm_hat_data_set_rules_form' => array(
      'render element' => 'form',
    ),
  );
}

// -----------------------------------------------------------------------
// Field type API

/**
 * Implements hook_field_info().
 */
function party_hat_field_info() {
  return array(
    'hat_reference' => array(
      'label' => t('Party hat reference'),
      'description' => t('Stores a reference to a party hat entity.'),
      'default_widget' => 'options_buttons',
      'default_formatter' => 'hat_reference_default',
      'module' => 'party_hat',
      'settings' => array(
        'entity_types' => array('party'),
      ),
      'instance_settings' => array(),
      'no_ui' => TRUE,
    )
  );
}

/**
 * Implements hook_field_settings_form().
 */
function party_hat_field_settings_form($field, $instance, $has_data) {
  return array();
}

/**
 * Implements hook_field_validate().
 */
function party_hat_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
}

/**
 * Implements hook_field_widget_error().
 */
function party_hat_field_widget_error($element, $error, $form, &$form_state) {
}

/**
 * Implements hook_field_is_empty().
 */
function party_hat_field_is_empty($item, $field) {
  if (empty($item['hat_name'])) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_field_widget_info_alter().
 */
function party_hat_widget_info_alter(&$info) {
  //Use options_select for the options
  $info['options_buttons']['field types'][] = 'hat_reference';
}

/**
 * Implements hook_options_list().
 */
function party_hat_options_list($field, $instance = NULL) {
  $hats = party_hat_get_all_hats();
  $options = array();
  if (isset($instance)) {
    $party_type = $instance['bundle'];
    foreach ($hats as $hat) {
      if (in_array($party_type, array_filter($hat->data['party_types']))) {
        $options[$hat->name] = $hat->label;
      }
    }
  }
  else {
    foreach ($hats as $hat) {
      $options[$hat->name] = $hat->label;
    }
  }

  return $options;
}

/**
 * Implements hook_field_presave().
 */
function party_hat_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
}

/**
 * Implements hook_field_formatter_info().
 */
function party_hat_field_formatter_info() {
  return array(
    'hat_reference_default' => array(
       'label' => t('Default'),
       'field types' => array('hat_reference'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function party_hat_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  switch ($display['type']) {
    case 'hat_reference_default':
      foreach($items as $delta => $item) {
        $hat = party_hat_load($item['hat_name']);

        $element[$delta]['#markup'] = $hat->label;
      }
    break;
  }
  return $element;
}

/**
 * Get Required Hats for Field Values
 */
function party_hat_field_get_default($entity_type, $entity, $field, $instance, $langcode = null) {
  //only works for party at the moment.
  if ($entity_type != 'party') {
    return array();
  }

  //Get required hats.
  $options = array(
    'required' => TRUE,
    'party_type' => $entity->type,
  );
  $hats = party_hat_get_all_hats($options);

  $values = array();
  foreach ($hats as $hat) {
    $values[] = array(
      'hat_name' => $hat->name,
    );
  }

  return $values;
}

// ----------------------------------------------------------------------------
// Form Alterations

/**
 * Additional validate handler to check party form for expected attached entities.
 *
 * This checks if all expected data sets are present and, if not, sends the user
 * back to the form with a nice message.
 */
function party_hat_party_form_hat_validate($form, $form_state) {
  $expected_data_sets = array();
  foreach (party_hat_get_hats($form_state['#party']) as $hid => $hat) {
    $expected_data_sets += party_hat_get_hat_data_sets($hat);
  }

  $attached_entities = $form_state['#attached_entities'];
  $existent_data_sets = array();
  foreach ($attached_entities as $attached_entity) {
    if (!in_array($attached_entity->data_set_name, $existent_data_sets)) {
      $existent_data_sets[] = $attached_entity->data_set_name;
    }
  }

  $missing_data_sets = array_diff($expected_data_sets, $existent_data_sets);
  foreach ($missing_data_sets as $data_set_name) {
    $data_set = party_get_data_set_info($data_set_name);
    form_set_error(NULL, t("Party %party is expected to have a %data-set which wasn't present. Please enter the data now.", array(
          '%party' => $form_state['#party']->label,
          '%data-set' => $data_set['label'],
        )));
  }
}

/**
 * Trigger Rules etc when a hat is assigned.
 */
function party_hat_party_form_hat_submit($form, &$form_state) {
  $party_unchanged = $form_state['#party_unchanged'];
  $party = $form_state['#party'];

  $old_hats = array_keys(party_hat_get_hats($party_unchanged));
  $hats = array_keys(party_hat_get_hats($party));
  $all_hats = array_merge($old_hats, $hats);

  $assigned_hats = array();
  $unassigned_hats = array();
  foreach (array_diff($old_hats, $hats) as $hat_name) {
    $unassigned_hats[] = $hat_name;
  }
  foreach (array_diff($hats, $old_hats) as $hat_name) {
    $assigned_hats[] = $hat_name;
  }
  unset($hats, $old_hats);

  //invoke hooks and rules to unassign hats
  if (!empty($unassigned_hats)) {
    if (module_exists('rules')) {
      rules_invoke_all('party_hat_unassign_hats', $party, $unassigned_hats);
    }
    else {
      module_invoke_all('party_hat_unassign_hats', $party, $unassigned_hats);
    }
  }

  // invoke hooks and rules to assign hats
  if (!empty($assigned_hats)) {
    if (module_exists('rules')) {
      rules_invoke_all('party_hat_assign_hats', $party, $assigned_hats);
    }
    else {
      module_invoke_all('party_hat_assign_hats', $party, $assigned_hats);
    }
  }
}

/**
 * Imlements hook_form_FORM_ID_alter.
 */
function party_hat_form_party_edit_form_alter(&$form, &$form_state) {
  $form['#validate'][] = 'party_hat_party_form_hat_validate';
  $form['#submit'][] = 'party_hat_party_form_hat_submit';
}