<?php
/**
 * @file party_hat.module
 * Provides an extensible access system for CRM parties.
 */

/**
 * Implements hook_entity_info().
 */
function party_hat_entity_info() {
  // The hat entity.
  $entity_info['party_hat'] = array(
    'label' => t('Hat'),
    'entity class' => 'PartyHat',
    'controller class' => 'PartyHatController',
    // We define this so entity module provides us with basic Views data, while
    // allowing us to define more of our own.
    // See http://drupal.org/node/1307760.
    'views controller class' => 'EntityDefaultViewsController',
    'base table' => 'party_hat',
    'fieldable' => TRUE,
    'module' => 'party',
    'entity keys' => array(
      'id' => 'hid'
    ),
    'exportable' => TRUE,
    'bundles' => array(
      'hat' => array(
        'label' => t('Hat'),
        'admin' => array(
          'path' => 'admin/community/hats',
          'access arguments' => array('administer hats'),
        ),
      ),
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full Hat'),
        'custom settings' =>  FALSE,
      ),
    )
  );
  return $entity_info;
}
 
/**
 * Implements hook_menu().
 */
function party_hat_menu() { 
  $items['admin/community/hats'] = array(
    'title' => 'Manage Hats',
    'description' => 'Manage hats',
    'page callback' => 'party_hat_manage',
    'access arguments' => array('administer hats'),
    'file' => 'party_hat.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/community/hats/add'] = array(
    'title' => 'Add hat',
    'description' => 'Manage hats',
    'page callback' => 'party_hat_add',
    'access arguments' => array('administer hats'),
    'file' => 'party_hat.admin.inc',
    'type' => MENU_LOCAL_ACTION,
  );
  $items['admin/community/hats/%party_hat/edit'] = array(
    'title' => 'Edit party hat',
    'description' => 'Edit a party hat',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('party_hat_edit_form', 3),
    'access arguments' => array('administer hats'),
    'file' => 'party_hat.admin.inc',
  );
  $items['admin/community/hats/%party_hat/delete'] = array(
    'title' => 'Delete Hat',
    'description' => 'Delete a party hat',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('party_hat_delete_form', 3),
    'access arguments' => array('administer hats'),
    'file' => 'party_hat.admin.inc',
  );
  
  

  return $items;
}


/**
 * Implements hook_permission().
 */
function party_hat_permission() {
  return array(
    'administer hats' => array(
      'title' => t('Administer CRM party hats'), 
      'description' => t('TODO write me.'),
    ),
  );
}

// -----------------------------------------------------------------------
// Party Hats API

/**
 * Save a hat.
 *
 * @param $hat a party_hat object.
 */
function party_hat_save(&$hat) {
  return entity_get_controller('party_hat')->save($hat);
}

/**
 * Load a hat.
 *
 * @param $hat_name
 *   The machine name of the hat to load.
 */
function party_hat_load($hat_name) {
  $query = db_select('party_hat', 'ph');
  $query->addField('ph', 'hid');
  $result = $query->condition('name', $hat_name, '=')
    ->execute()
    ->fetchAllAssoc('hid');
  
  $ids = array_keys($result);
  
  // @todo WTF? If $hat_name can be a numeric id it needs to be documented.
  if (count($ids) < 1 && is_numeric($hat_name)) {
    $ids = array($hat_name);
  }
  return reset(party_hat_load_multiple($ids));
}

/**
 * Load many hats.
 */
function party_hat_load_multiple($hids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('party_hat', $hids, $conditions, $reset);
}

/**
 * Save a hat data set rule.
 *
 * @param $hat
 *  The hat name
 * @param $set
 *  The set type
 *  @todo: does this mean the data set name? if so, rename.
 * @param $value
 *  The value
 *
 * @todo Refactor so that we don't do 3 queries to update one rule. 
 *       At the moment we do 3 queries when we add a rule and 1 when we update it and 2 when we keep it the same..
 *       Is this better than 2 queries for both?
 */
function party_hat_set_data_set_rule($hat, $set, $values = array()) {
  //try updating the table
  $num_affected = db_update('party_hat_data_set_rules')
    ->fields($values)
    ->condition('hat', $hat, '=')
    ->condition('data_set', $set, '=')
    ->execute();
    
  if ($num_affected < 1) {
    // We have to check that we haven't kept the row the same.
    // @todo: refactor this so that we don't do 3 queries
    $count = db_select('party_hat_data_set_rules', 'c')
      ->fields('c')
      ->condition('hat', $hat, '=')
      ->condition('data_set', $set, '=')
      ->execute()
      ->rowCount();
    
    if ($count < 1) {  
      $data = array(
        'hat' => $hat,
        'data_set' => $set,
      ) + $values;
      drupal_write_record('party_hat_data_set_rules',  $data);
    }
  }
}

/**
 * Get a hat data set rule.
 *
 * @param $hat
 *  The hat name
 * @param $set
 *  The set type
 *  @todo: does this mean the data set name? if so, rename.
 *
 * @return
 *  @todo write me.
 */
function party_hat_get_data_set_rule($hat, $set) {
  //select from the table where the hat and data set are right
  $results = db_select('party_hat_data_set_rules', 'c')
    ->fields('c')
    ->condition('hat', $hat, '=')
    ->condition('data_set', $set, '=')
    ->execute()
    ->fetchAllAssoc('phdsid');
  
  //if the rule doesn't exist yet return a default.
  if (count($results) < 1) {
    return array(
      'has' => 0,
      'multiple' => 0,
    );
  }
  
  //get the first $result (there should only ever be one)
  $result = reset($results);
  return array(
    'has' => $result->has,
    'multiple' => $result->multiple,
  );
}

/**
 * Implements hook_party_access().
 */
function party_hat_party_access($op, $party = NULL, $attached_entity = NULL, $account = NULL) {
  // We say nothing about access to just the party.
  if (!isset($attached_entity)) {
    return NULL;
  }

  switch ($op) {
    case 'attach':
      $data_set_name = $attached_entity;

      $party_hats = party_hat_get_hats($party);
      $data_sets = array();
      foreach ($party_hats as $hat) {
        // Ugh these are values; would be better as keys.
        $hat_sets = party_hat_get_hat_data_sets($hat);
        // If any hat has the data set, grant access.
        if (in_array($data_set_name, $hat_sets)) {
          return TRUE;
        }
      }
      return NULL;
    case 'view':
      // @todo: This needs to be written! Just say yes for now.
      return TRUE;

  }
}

/**
 * Get all the sets for a Hat.
 *
 * This returns an array of sets that a Party Must have or can have multiple of.
 *
 * @todo write params and return.
 */
function party_hat_get_hat_data_sets($hat, $rule = 'has') {
   
  $results = db_select('party_hat_data_set_rules', 'c')
    ->fields('c')
    ->condition('hat', $hat->name, '=')
    ->condition($rule, 1, '=')
    ->execute()
    ->fetchAllAssoc('data_set');
  
  return array_keys($results);
}

/**
 * Get all the Hats a Party is Wearing
 *
 * @param $party 
 *  The Party object or ID
 */
function party_hat_get_hats($party) {
  if (!is_object($party)) {
    $party = party_load($party);
  }
  
  $hats = array();
  // If this is an unsaved party (one without an ID)...
  if (!isset($party->pid)) {
    //Get all the "required"/"default" hats for this party type.
    $options = array(
      'required' => TRUE,
      'party_type' => $party->type,
    );
    return party_hat_get_all_hats($options);
  }
  else {
    if (isset($party->party_hat) && is_array($party->party_hat)) {
      foreach ($party->party_hat['und'] as $hat_name) {
        $hat = party_hat_load($hat_name);
        $hats[$hat->hid] = $hat; 
      }
    }
  }
  
  return $hats;  
}

/**
 * Get all available hats.
 *
 * @todo: Make filter by party type.
 */
function party_hat_get_all_hats($options = array()) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'party_hat', '=');
  if (isset($options['required']) && $options['required']) {
    // filter the search by whether they're required 
    $query->propertyCondition('required', 1, '=');
  }
  $result = $query->execute();
  $hids = array();
  
  if (!isset($result['party_hat']) || !is_array($result['party_hat'])) {
    return array();
  }
  
  foreach ($result['party_hat'] as $record) {
    $hids[] = $record->hid;
  }
  $hats = entity_load('party_hat', $hids);
  
  if (!isset($options['party_type'])) {
    return $hats;
  }
  
  foreach ($hats as $id => $hat) {
    if (!in_array($options['party_type'], $hat->data['party_types'])) {
      unset($hats[$id]);
    }
  }
  return $hats;  
}

/**
 * Implements hook_theme().
 */
function party_hat_theme($existing, $type, $theme, $path) {
  return array(
    'crm_hat_data_set_rules_form' => array(
      'render element' => 'form',
    ),
  );
}

// -----------------------------------------------------------------------
// Field type API

/**
 * Implements hook_field_info().
 */
function party_hat_field_info() {
  return array(
    'hat_reference' => array(
      'label' => t('Party hat reference'),
      'description' => t('Stores a reference to a party hat entity.'),
      'default_widget' => 'options_buttons',
      'default_formatter' => 'hat_reference_default',
      'module' => 'party_hat',
      'settings' => array(
        'entity_types' => array('party'),
      ),
      'instance_settings' => array(),
      'no_ui' => TRUE,
    )
  );
}

/**
 * Implements hook_field_settings_form().
 */
function party_hat_field_settings_form($field, $instance, $has_data) {
  return array();
}

/**
 * Implements hook_field_validate().
 */
function party_hat_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
}

/**
 * Implements hook_field_widget_error().
 */
function party_hat_field_widget_error($element, $error, $form, &$form_state) {
}

/**
 * Implements hook_field_is_empty().
 */
function party_hat_field_is_empty() {
  return FALSE;
}

/**
 * Implements hook_field_widget_info_alter().
 */
function party_hat_widget_info_alter(&$info) {
  //Use options_select for the options
  $info['options_buttons']['field types'][] = 'hat_reference';
}

/**
 * Implements hook_options_list().
 */
function party_hat_options_list($field, $instance = NULL) {
  $hats = party_hat_get_all_hats();
  $options = array();
  if (isset($instance)) {
    $party_type = $instance['bundle'];
    foreach ($hats as $hat) {
      if (in_array($party_type, array_filter($hat->data['party_types']))) {
        $options[$hat->name] = $hat->label;
      }
    }
  }
  else {
    foreach ($hats as $hat) {
      $options[$hat->name] = $hat->label;
    }
  }

  return $options;
}

/**
 * Implements hook_field_presave().
 */
function party_hat_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
}

/**
 * Implements hook_field_formatter_info().
 */
function party_hat_field_formatter_info() {
  return array(
    'hat_reference_default' => array(
       'label' => t('Default'),
       'field types' => array('hat_reference'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function party_hat_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  switch ($display['type']) {
    case 'hat_reference_default':
      foreach($items as $delta => $item) {
        $hat = party_hat_load($item['hat_name']);

        $element[$delta]['#markup'] = $hat->label;
      }
    break;
  }
  return $element;
}

/**
 * Get Required Hats for Field Values
 */
function party_hat_field_get_default($entity_type, $entity, $field, $instance, $langcode = null) {
  //only works for party at the moment.
  if ($entity_type != 'party') {
    return array();
  }
  
  //Get required hats.
  $options = array(
    'required' => TRUE,
    'party_type' => $entity->type,
  );
  $hats = party_hat_get_all_hats($options);
  
  $values = array();
  foreach ($hats as $hat) {
    $values[] = array(
      'hat_name' => $hat->name,
    );
  }
  
  return $values;
}

/**
 * Additional submit handler to check party form for expected attached entities.
 *
 * This checks if all expected data sets are present and, if not, sends the user
 * back to the form with a nice message.
 *
 * @todo: surely this should be a validation handler?
 */
function party_hat_party_form_hat_check($form, &$form_state) {
  foreach (party_hat_get_hats($form_state['#party']) as $hid => $hat) {
    $data_sets = party_hat_get_hat_data_sets($hat);
        
    foreach ($data_sets as $data_set_name) {
      $attached_entities = party_get_attached_entities($form_state['#party'], $data_set_name);
      if (count($attached_entities) < 1) {
        $data_set_info = party_get_data_set_info($data_set_name);
        $form_state['redirect'] = 'party/' . $form_state['#party']->pid . '/party/edit';
        drupal_set_message(t("Party %party is expected to have a %data-set which wasn't present. Please enter the data now.", array(
          '%party' => $form_state['#party']->label,
          '%data-set' => $data_set_info['label'],
        )));
      }
    }
  }
}
